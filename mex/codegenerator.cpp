/*
  Copyright (C) 2017 Julian Sp√§th
  ----------------------------------------------------------------------------
  This file is part of AMMSoCK.

  AMMSoCK is free software: you can redistribute it and/or modify it under the
  terms of the GNU General Public License as published by the Free Software
  Foundation, either version 3 of the License, or (at your option) any later
  version. AMMSoCK is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
  details. You should have received a copy of the GNU General Public License
  along with AMMSoCK. If not, see <https://www.gnu.org/licenses/>.
*/

#include <algorithm>
#include <assert.h>
#include <cmath>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <map>
#include <sstream>
#include <string>
#include <time.h>
#include <vector>

// get AMMSoCK stats: nstages, Acoll and nrpv
#include "./cpp/generationStats.hpp"

using namespace std;

int thirdBodyOccurs(vector<int> bodyPos, int index) {
  for (int i = 0; i < bodyPos.size(); ++i) {
    if (bodyPos[i] == (index + 1)) {
      return i;
    }
  }
  return -1;
}

int getIndexOfToken(string token, vector<string> species) {
  for (int i = 0; i < species.size(); i++) {
    if (species[i].compare(token) == 0) {
      return i;
    };
  }
  return -1;
}

void generateBoundsInfo(int nspec, vector<string> species, int natom,
                        string filename) {

  // get time for time stamp
  time_t t;
  time(&t);

  ofstream out("get_bounds_info.hpp");
  out << "/* Autogenerated file on " << ctime(&t);
  out << " *    Function defining the boundaries, i.e. the upper and lower "
         "bounds of the optimization problem"
      << endl;
  out << " *    Mechanism: " << filename << endl;
  out << " */" << endl;
  out << "bool ammsockNLP::get_bounds_info(Index n, Number* x_l, Number* x_u, "
         "Index m, Number* g_l, Number* g_u) {"
      << endl
      << endl;

  // prepare preliminares
  out << "   // Assertions" << endl;
  out << "   assert(n == " << ((NINT + 1) * NSTAGES + 1) * (NOP + 1) << ");"
      << endl;
  if (NNOP > 0) {
    out << "   assert(m == "
        << NRPV + (NINT + 1) * NSTAGES * (NOP + 1) + 1 +
               NNOP * ((NINT + 1) * NSTAGES + 1)
        << ");" << endl;
  } else {
    out << "   assert(m == "
        << NRPV + (NINT + 1) * NSTAGES * (NOP + 1) + 1 + NATOM << ");" << endl;
  }
  out << endl;

  // upper and lower bound for optimization variables
  out << "   //set lower and upper bounds for op variables" << endl;
  out << "   for (int i = 0; i < n; ++i) {" << endl;
  out << "      x_l[i] = 0.0;" << endl;
  out << "      //set upper bound for the temperatures to 4000 Kelvin" << endl;
  out << "      if ((i+1)%" << NOP + 1 << " == 0) {" << endl;
  out << "         x_u[i] = 4000.0;" << endl;
  out << "      } else {" << endl;
  out << "         x_u[i] = 1.0;" << endl;
  out << "      }" << endl;
  out << "   }" << endl << endl;

  // upper and lower bound for constraints
  int upper = -1;
  if (NNOP > 0) {
    upper = NRPV + (NINT + 1) * NSTAGES * (NOP + 1) + 1;
  } else {
    upper = NRPV + (NINT + 1) * NSTAGES * (NOP + 1) + 1 + NATOM;
  }
  out << "   //set lower and upper bounds for constraints" << endl;
  out << "   for (int i = 0; i < " << upper << "; ++i) {" << endl;
  out << "      g_l[i] = 0.0;" << endl;
  out << "      g_u[i] = 0.0;" << endl;
  out << "   }" << endl << endl;
  out << "   //set low and upper bounds for nontrivial inequailities "
         "(resolution)"
      << endl;
  out << "   for (int i = " << upper << "; i < m; ++i) {" << endl;
  out << "      g_l[i] = 0.0;" << endl;
  out << "      g_u[i] = 1.0;" << endl;
  out << "   }" << endl << endl;

  out << "   return true;" << endl;
  out << endl;
  out << "}" << endl;
  out.close();
}

void generateNLPInfo(int nspec, vector<string> species, int natom,
                     string filename) {

  // get time for time stamp
  time_t t;
  time(&t);

  ofstream out("get_nlp_info.hpp");
  out << "/* Autogenerated file on " << ctime(&t);
  out << " *    Function defining the essential informations of the "
         "optimization problem"
      << endl;
  out << " *    Mechanism: " << filename << endl;
  out << " */" << endl;
  out << "bool ammsockNLP::get_nlp_info(Index& n, Index& m, Index& nnz_jac_g, "
         "Index& nnz_h_lag, IndexStyleEnum& index_style){"
      << endl
      << endl;

  // set problem dimension
  out << "   //set problem dimension" << endl;
  out << "   n = " << ((NINT + 1) * NSTAGES + 1) * (NOP + 1) << ";" << endl;
  if (NNOP > 0) {
    out << "   m = "
        << NRPV + (NINT + 1) * NSTAGES * (NOP + 1) + 1 +
               NNOP * ((NINT + 1) * NSTAGES + 1)
        << ";" << endl;
  } else {
    out << "   m = " << NRPV + (NINT + 1) * NSTAGES * (NOP + 1) + 1 + NATOM
        << ";" << endl;
  }
  out << endl;

  // set nonzeros in jacobian and hessian
  out << "   //set nonzeros in jacobian and hessian" << endl;
  if (NNOP > 0) {
    out << "   nnz_jac_g = "
        << NSTAGES * NOP + (NOP + 1) + NINT * NSTAGES * NOP +
               (NINT + 1) *
                   (NSTAGES * NSTAGES * NOP * (NOP + 1) + (NOP + 1) * NSTAGES) +
               NRPV + (NSTAGES * (NINT + 1) + 1) * NOP * NNOP
        << ";" << endl;
  } else {
    out << "   nnz_jac_g = "
        << NSTAGES * NOP + (NOP + 1) + NINT * NSTAGES * NOP +
               (NINT + 1) *
                   (NSTAGES * NSTAGES * NOP * (NOP + 1) + (NOP + 1) * NSTAGES) +
               NRPV + NATOM * NOP
        << ";" << endl;
  }
  out << "   nnz_h_lag = "
      << (NOP + 1) * (NOP + 1) + (NINT + 1) * NSTAGES * (NOP + 1) * (NOP + 1)
      << ";" << endl;
  out << endl;

  // set index style
  out << "   //set index style" << endl;
  out << "   index_style = FORTRAN_STYLE;" << endl;
  out << endl;

  out << "   return true;" << endl;
  out << endl;
  out << "}" << endl;
  out.close();
}

void generateRHS(int nspec, int nreac, int natom, vector<string> species,
                 vector<vector<int>> nuprime, vector<vector<int>> nu2prime,
                 vector<int> bodyPos, vector<int> bodyNumber,
                 vector<vector<double>> bodyCoeff, vector<double> Ms,
                 vector<vector<double>> nasa, vector<double> switchingPoints,
                 string filename, string path) {

  int nop = NOP;
  int Iop[NOP] = IOP;
  int Inop[NNOP] = INOP;

  // generate nu
  vector<vector<int>> nu(nspec, vector<int>(nreac, 0));
  for (int i = 0; i < nu.size(); ++i) {
    for (int k = 0; k < nu[0].size(); ++k) {
      nu[i][k] = nu2prime[i][k] - nuprime[i][k];
    }
  }

  // get time for time stamp
  time_t t;
  time(&t);

  // ofstream rhs(("rhs_"+filename+".m").c_str());
  ofstream rhs("odefun.py");
  rhs << "# Autogenerated file on " << ctime(&t);
  rhs << "# odefun.py" << endl;
  rhs << "#    Description: Calculates the change of mass fractions of each "
         "species"
      << endl;
  rhs << "#    Input: t - time." << endl;
  rhs << "#           X = (Y,T) - with mass fractions Y of each species and"
      << endl;
  rhs << "#                        temperature T." << endl;
  rhs << "#           param - dictionary containing resolution if present."
      << endl;
  rhs << "#    Output: f - change of mass fractions of each species." << endl;
  rhs << "import numpy as np" << endl;
  rhs << "import sys" << endl;
  rhs << "import os" << endl;
  rhs << endl;
  rhs << "#add workingDir/python to search path to import rates.py" << endl;
  rhs << "path = '" << path << "'" << endl;
  rhs << "new_path = path.replace('\mech','\python')" << endl;
  rhs << "sys.path.append(os.path.abspath(new_path))" << endl;
  rhs << "from rates import *" << endl;
  rhs << endl;
  rhs << "def odefun(X,t,param):" << endl << endl;

  rhs << "\t# Preliminaries" << endl;
  rhs << "\tY = np.zeros(" << nspec << ")" << endl;
  rhs << "\t# set Iop variables" << endl;
  for (int i = 0; i < NOP; ++i) {
    rhs << "\tY[" << Iop[i] - 1 << "] = X[" << i << "]" << endl;
  }
  rhs << "\t# set Inop variables" << endl;
  for (int i = 0; i < NOP; ++i) {
    rhs << "\tY" << i + 1 << " = X[" << i << "]" << endl;
  }
  for (int i = 0; i < NNOP; ++i) {
    rhs << "\tY[" << Inop[i] - 1 << "] = eval(param[" << i << "])" << endl;
  }
  rhs << endl;
  rhs << "\tT = X[-1]" << endl;
  rhs << "\t[kf,kr,_,_,_,_] = rates(T)" << endl;
  rhs << "\tgamma = 20 # transition parameter" << endl;

  // generating nasa
  rhs << "\tnasa = np.array([";
  for (int i = 0; i < nspec; ++i) {
    if (i == 0) {
      rhs << "[";
    } else {
      rhs << "\t[";
    }
    for (int k = 0; k < 14; ++k) {
      rhs << std::setprecision(15) << nasa[i][k] << ",";
    }
    rhs << "]," << endl;
  }
  rhs << "\t]) # coefficients for nasa polynomials - each line: "
         "[a1_low,...,a7_low,a1_high,..,a7_high]"
      << endl;

  // generating switching points
  rhs << "\tT_sw = np.array([";
  for (int k = 0; k < nspec; ++k) {
    rhs << switchingPoints[k] << ",";
  }
  rhs << "]) # switching points between branches" << endl;
  rhs << "\tq = np.zeros(" << nreac << ")" << endl;
  rhs << "\tM = np.zeros(" << bodyCoeff.size() << ")" << endl;
  rhs << "\tomega = np.zeros(" << nspec << ")" << endl;
  rhs << "\tf = np.zeros(" << nop + 1 << ")" << endl;
  rhs << "\tC_low = np.zeros(" << nspec << ")" << endl;
  rhs << "\tC_high = np.zeros(" << nspec << ")" << endl;
  rhs << "\tH_low = np.zeros(" << nspec << ")" << endl;
  rhs << "\tH_high = np.zeros(" << nspec << ")" << endl;
  rhs << "\tCbar = np.zeros(" << nspec << ")" << endl;
  rhs << "\tHbar = np.zeros(" << nspec << ")" << endl;
  rhs << "\tMs = np.array([";
  for (int i = 0; i < Ms.size(); ++i) {
    rhs << std::setprecision(15) << 1e-3 * Ms[i] << ",";
  }
  rhs << "]) # molar weights in kg/mol" << endl;
  rhs << "\tp = 101325 # fixed pressure (1 atm) in isobaric case" << endl;
  rhs << "\tR = 8.3144598" << endl;
  rhs << "\tMbar = 1/np.sum(Y/Ms)" << endl;
  rhs << "\trho = p*Mbar/(R*T)" << endl << endl;

  // generating Hbar_{low,high}
  rhs << endl << "\t# calculate H_{low,high}" << endl;
  rhs << "\tfor i in range(0," << nspec << "):" << endl;
  rhs << "\t   C_low[i]  = R*(nasa[i,0] + nasa[i,1]*T + nasa[i,2]*T**2 + "
         "nasa[i,3]*T**3 + nasa[i,4]*T**4)"
      << endl;
  rhs << "\t   C_high[i] = R*(nasa[i,7] + nasa[i,8]*T + nasa[i,9]*T**2 + "
         "nasa[i,10]*T**3 + nasa[i,11]*T**4)"
      << endl;
  rhs << "\t   H_low[i]  = R*(nasa[i,0]*T + nasa[i,1]/2*T**2 + "
         "nasa[i,2]/3*T**3 + nasa[i,3]/4*T**4 + nasa[i,4]/5*T**5 + nasa[i,5])"
      << endl;
  rhs << "\t   H_high[i] = R*(nasa[i,7]*T + nasa[i,8]/2*T**2 + "
         "nasa[i,9]/3*T**3 + nasa[i,10]/4*T**4 + nasa[i,11]/5*T**5 + "
         "nasa[i,12])"
      << endl;

  // generating Hbar
  rhs << "\t# calculate Hbar" << endl;
  rhs << "\tfor i in range(0," << nspec << "):" << endl;
  rhs << "\t   sigma = 1/2*np.tanh(gamma*(T-T_sw[i])) + 1/2" << endl;
  rhs << "\t   Hbar[i] = (1-sigma)*H_low[i] + sigma*H_high[i]" << endl;
  rhs << "\t   Cbar[i] = (1-sigma)*C_low[i] + sigma*C_high[i]" << endl;

  // generating third bodies
  rhs << "\t# Generate third bodies" << endl;
  for (int i = 0; i < bodyCoeff.size(); ++i) {
    rhs << "\tM[" << i << "] = 0.0";
    for (int k = 0; k < nspec; ++k) {
      rhs << " + " << bodyCoeff[i][k] << " * rho*Y[" << k << "]/Ms[" << k
          << "]";
    }
    rhs << endl;
  }
  rhs << endl;

  // generating q_r
  rhs << "\t# Generate each reaction q_r" << endl;
  for (int i = 0; i < nreac; ++i) {
    rhs << "\tq[" << i << "] = "
        << "kf[" << i << "] ";
    for (int s = 0; s < nspec; ++s) {
      int exponent = nuprime[s][i];
      if (exponent != 0) {
        for (int k = 1; k <= exponent; ++k) {
          rhs << "* rho * Y[" << s << "]/Ms[" << s << "] ";
        }
      }
    }
    rhs << " - kr[" << i << "] ";
    for (int s = 0; s < nspec; ++s) {
      int exponent = nu2prime[s][i];
      if (exponent != 0) {
        for (int k = 1; k <= exponent; ++k) {
          rhs << "* rho * Y[" << s << "]/Ms[" << s << "] ";
        }
      }
    }
    rhs << endl;
  }
  rhs << endl;

  // link q_r and third bodies
  rhs << "\t# Insert third bodies into reactions" << endl;
  for (int i = 0; i < bodyNumber.size(); ++i) {
    rhs << "\tq[" << bodyPos[i] - 1 << "] = M[" << bodyNumber[i] - 1 << "] * q["
        << bodyPos[i] - 1 << "]" << endl;
  }
  rhs << endl;

  // generating omega
  rhs << "\t# Generate omega" << endl;
  for (int s = 0; s < nspec; ++s) {
    rhs << "\tomega[" << s << "] = 0 ";
    for (int r = 0; r < nreac; ++r) {
      if (nu[s][r] != 0)
        rhs << "+ (" << nu[s][r] << ") * "
            << "q[" << r << "] ";
    }
    rhs << endl;
  }
  rhs << endl;

  // generating dotY
  rhs << "\t# Generate dotY" << endl;
  for (int s = 0; s < nop; ++s) {
    rhs << "\tf[" << s << "] = Ms[" << Iop[s] - 1 << "]/rho * omega["
        << Iop[s] - 1 << "]" << endl;
  }

  rhs << "\tf[" << nop
      << "] = - (R*T*np.sum(Hbar*omega) * np.sum(Y/Ms)) / (p * "
         "np.sum(Cbar*Y/Ms))"
      << endl;
  rhs << "\treturn f" << endl;
  rhs.close();
}

void generateEvalF(int nspec, int nreac, vector<string> species,
                   vector<vector<int>> nuprime, vector<vector<int>> nu2prime,
                   vector<int> bodyPos, vector<int> bodyNumber,
                   vector<vector<double>> bodyCoeff, vector<double> Ms,
                   string filename) {

  int nop = NOP;

  // generate nu
  vector<vector<int>> nu(nspec, vector<int>(nreac, 0));
  for (int i = 0; i < nu.size(); ++i) {
    for (int k = 0; k < nu[0].size(); ++k) {
      nu[i][k] = nu2prime[i][k] - nuprime[i][k];
    }
  }

  // get time for time stamp
  time_t t;
  time(&t);

  ofstream evalf("eval_f.hpp");
  evalf << "/* Autogenerated file on " << ctime(&t);
  evalf << " *    Function defining the objective functional" << endl;
  evalf << " *    Mechanism: " << filename << endl;
  evalf << " */" << endl;
  //		evalf << endl << "#include <rates.hpp>" << endl << endl;
  evalf << "bool ammsockNLP::eval_f(Index n, const Number* x, bool new_x, "
           "Number& objvalue) {"
        << endl
        << endl;

  // rename variables
  evalf << "   // Preliminaries - get (Y00,T00)" << endl;
  evalf << "   Number Y[" << nop << "];" << endl;
  for (int i = 0; i < nop; ++i) {
    evalf << "   Y[" << i << "] = x[" << i << "];" << endl;
  }
  evalf << "   Number T = x[" << nop << "];" << endl << endl;

  // get first derivative
  evalf << "   // get f and first derivative dYf" << endl;
  evalf << "   Number f[" << nop << "], dTf[" << nop << "], dYf[" << nop << "]["
        << nop << "], H[" << nspec << "], dTH[" << nspec << "];" << endl;
  evalf << "   getFirstDerivative_f(T, Y, f, dYf, dTf, H, dTH);" << endl
        << endl;

  // generate objval
  evalf << "   // Generate objvalue" << endl;
  evalf << "   objvalue = 0.0;" << endl;
  for (int i = 0; i < nop; ++i) {
    evalf << "   objvalue += pow( 0.0 ";
    for (int j = 0; j < nop; ++j) {
      evalf << " + dYf[" << i << "][" << j << "]*f[" << j << "]";
    }
    evalf << ",2);" << endl;
  }

  // scale objvalue
  evalf << endl << "   // scale objvalue" << endl;
  evalf << "   objvalue *= scale;" << endl;

  evalf << endl << "   return true;" << endl;
  evalf << "}" << endl;
  evalf.close();
}

void generateEvalGradF(int nspec, int nreac, vector<string> species,
                       vector<vector<int>> nuprime,
                       vector<vector<int>> nu2prime, vector<int> bodyPos,
                       vector<int> bodyNumber, vector<vector<double>> bodyCoeff,
                       vector<double> Ms, string filename) {

  int nop = NOP;

  // generate nu
  vector<vector<int>> nu(nspec, vector<int>(nreac, 0));
  for (int i = 0; i < nu.size(); ++i) {
    for (int k = 0; k < nu[0].size(); ++k) {
      nu[i][k] = nu2prime[i][k] - nuprime[i][k];
    }
  }

  // get time for time stamp
  time_t t;
  time(&t);

  ofstream evalf("eval_grad_f.hpp");
  evalf << "/* Autogenerated file on " << ctime(&t);
  evalf << " *    Function defining the gradient of the objective functional"
        << endl;
  evalf << " *    Mechanism: " << filename << endl;
  evalf << " */" << endl;
  evalf << "bool ammsockNLP::eval_grad_f(Index n, const Number* x, bool new_x, "
           "Number* grad_f) {"
        << endl
        << endl;

  // rename variables
  evalf << "   //get variables (Y_0_0,T_0_0)" << endl;
  evalf << "   Number Y[" << nop << "];" << endl;
  for (int i = 0; i < nop; ++i) {
    evalf << "   Y[" << i << "] = x[" << i << "];" << endl;
  }
  evalf << "   Number T = x[" << nop << "];" << endl;
  evalf << endl;

  // prepare preliminares
  evalf << "   // Preliminaries" << endl;
  evalf << "   Number f[" << nop << "], dYf[" << nop << "][" << nop << "], dTf["
        << nop << "], dYYf[" << nop << "][" << nop << "][" << nop << "], dYTf["
        << nop << "][" << nop << "];" << endl;
  evalf << "   Number H[" << nspec << "], dTH[" << nspec << "], dTTH[" << nspec
        << "];" << endl;
  evalf << endl;

  evalf << "   //get required derivatives" << endl;
  evalf << "   getSecondDerivative_f(T,Y,f,dYf,dTf,dYYf,dYTf,H,dTH,dTTH);"
        << endl;
  evalf << endl;

  // generate gradF
  evalf << "   // Generate gradient grad_F" << endl;
  for (int m = 0; m < nop; ++m) {
    evalf << "   grad_f[" << m << "] = 0.0;" << endl;
    for (int i = 0; i < nop; ++i) {
      evalf << "   grad_f[" << m << "] += 2.0 * ( 0.0";
      for (int s = 0; s < nop; ++s) {
        evalf << " + dYf[" << i << "][" << s << "] * f[" << s << "]";
      }
      evalf << ") * ( 0.0";
      for (int s = 0; s < nop; ++s) {
        evalf << " + dYYf[" << i << "][" << s << "][" << m << "] * f[" << s
              << "] + dYf[" << i << "][" << s << "] * dYf[" << s << "][" << m
              << "]";
      }
      evalf << ");" << endl;
    }
    evalf << endl;
  }

  // generate gradF
  evalf << "   // Generate gradient grad_F resp. T" << endl;
  evalf << "   grad_f[" << nop << "] = 0.0;" << endl;
  for (int i = 0; i < nop; ++i) {
    evalf << "   grad_f[" << nop << "] += 2.0 * ( 0.0";
    for (int s = 0; s < nop; ++s) {
      evalf << " + dYf[" << i << "][" << s << "] * f[" << s << "]";
    }
    evalf << ") * ( 0.0";
    for (int s = 0; s < nop; ++s) {
      evalf << " + dYTf[" << i << "][" << s << "] * f[" << s << "] + dYf[" << i
            << "][" << s << "] * dTf[" << s << "]";
    }
    evalf << ");" << endl;
  }
  evalf << endl;

  // scale gradient
  evalf << "   // scale gradient" << endl;
  for (int i = 0; i < nop + 1; ++i) {
    evalf << "   grad_f[" << i << "] *= scale;" << endl;
  }
  evalf << endl;

  // set rest to zero
  evalf << "   //set rest to zero" << endl;
  evalf << "   for (int i = " << nop + 1 << "; i < n; ++i) {" << endl;
  evalf << "      grad_f[i] = 0.0;" << endl;
  evalf << "   }" << endl;

  evalf << endl << endl << "   return true;" << endl;
  evalf << "}" << endl;
  evalf.close();
}

void generateEvalH(int nspec, int nreac, vector<string> species,
                   vector<vector<int>> nuprime, vector<vector<int>> nu2prime,
                   vector<int> bodyPos, vector<int> bodyNumber,
                   vector<vector<double>> bodyCoeff, vector<double> Ms,
                   string filename) {

  // set collocation schema
  double A[NSTAGES][NSTAGES] = ACOLL;

  // get problem dimensions
  int nop = NOP;
  int nnop = NNOP;
  int Iop[NOP] = IOP;
  int Inop[NNOP] = INOP;

  // generate nu
  int nu[nspec][nreac];
  for (int i = 0; i < nspec; ++i) {
    for (int k = 0; k < nreac; ++k) {
      nu[i][k] = nu2prime[i][k] - nuprime[i][k];
    }
  }

  // get time for time stamp
  time_t t;
  time(&t);

  ofstream evalh("eval_h.hpp");
  evalh << "/* Autogenerated file on " << ctime(&t);
  evalh << " *    Function defining the exact Hessian of the lagrangian funtion"
        << endl;
  evalh << " *    Mechanism: " << filename << endl;
  evalh << " */" << endl;
  evalh << "bool ammsockNLP::eval_h(Index n, const Number* x, bool new_x, "
           "Number obj_factor, Index m, const Number* lambda, bool new_lambda, "
           "Index nele_hess, Index* iRow, Index *jCol, Number* values) {"
        << endl
        << endl;

  if (EXACTHESSIAN) {
    // check structure
    int n = ((NINT + 1) * NSTAGES + 1) * (NOP + 1);
    int nnzHess = 0;
    evalh << "   if (values == NULL) {" << endl;
    for (int i = 1; i <= n; ++i) {
      for (int j = 1; j <= (NOP + 1); ++j) {
        evalh << "      iRow[" << nnzHess << "] = " << i << "; jCol[" << nnzHess
              << "] = " << ((int)(i - 1) / (NOP + 1)) * (NOP + 1) + j << ";"
              << endl;
        nnzHess++;
      }
    }
    evalh << "   } else {" << endl;

    // rename variables
    evalh << endl
          << "   //set variables and molar weights - coding NAME_INTERVAL_STAGE"
          << endl;
    evalh << std::setprecision(20);
    evalh << "   Number Ms[" << nspec << "] = { " << 1e-3 * Ms[0];
    for (int i = 1; i < Ms.size(); ++i) {
      evalh << ", " << 1e-3 * Ms[i];
    }
    evalh << "}; //molar weights in kg/mol" << endl;
    evalh << "   Number Y_0_0[" << nop << "] = { x[0]";
    for (int i = 1; i < nop; ++i) {
      evalh << ",  x[" << i << "]";
    }
    evalh << "}, T_0_0 = x[" << nop << "];" << endl;

    for (int k = 0; k <= NINT; ++k) {
      for (int s = 1; s <= NSTAGES; ++s) {
        evalh << "   Number Y_" << k << "_" << s << "[" << nop << "] = { x["
              << nop + k * NSTAGES * (nop + 1) + (s - 1) * (nop + 1) + 1 << "]";
        for (int i = 1; i < nop; ++i) {
          evalh << ", x["
                << nop + k * NSTAGES * (nop + 1) + (s - 1) * (nop + 1) + i + 1
                << "]";
        }
        evalh << "}, T_" << k << "_" << s << " = x["
              << nop + k * NSTAGES * (nop + 1) + (s - 1) * (nop + 1) + nop + 1
              << "];" << endl;
      }
    }
    evalh << endl;

    // allocate memory for required derivatives
    evalh << "   // allocate memory for required derivatives" << endl;
    evalh << "   Number f_0_0[" << nop << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", f_" << k << "_" << i << "[" << nop << "]";
      }
    }
    evalh << ";" << endl;
    evalh << "   Number H_0_0[" << nspec << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", H_" << k << "_" << i << "[" << nspec << "]";
      }
    }
    evalh << ";" << endl;
    evalh << "   Number Yres_0_0[" << nnop << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", Yres_" << k << "_" << i << "[" << nnop << "]";
      }
    }
    evalh << ";" << endl;
    evalh << "   Number dTf_0_0[" << nop << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", dTf_" << k << "_" << i << "[" << nop << "]";
      }
    }
    evalh << ";" << endl;
    evalh << "   Number dTH_0_0[" << nspec << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", dTH_" << k << "_" << i << "[" << nspec << "]";
      }
    }
    evalh << ";" << endl;
    evalh << "   Number dYf_0_0[" << nop << "][" << nop << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", dYf_" << k << "_" << i << "[" << nop << "][" << nop << "]";
      }
    }
    evalh << ";" << endl;
    evalh << "   Number dYYres_0_0[" << nnop << "][" << nop << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", dYYres_" << k << "_" << i << "[" << nnop << "][" << nop
              << "]";
      }
    }
    evalh << ";" << endl;
    evalh << "   Number dYYf_0_0[" << nop << "][" << nop << "][" << nop << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", dYYf_" << k << "_" << i << "[" << nop << "][" << nop << "]["
              << nop << "]";
      }
    }
    evalh << ";" << endl;
    evalh << "   Number dYTf_0_0[" << nop << "][" << nop << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", dYTf_" << k << "_" << i << "[" << nop << "][" << nop << "]";
      }
    }
    evalh << ";" << endl;
    evalh << "   Number dTTf_0_0[" << nop << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", dTTf_" << k << "_" << i << "[" << nop << "]";
      }
    }
    evalh << ";" << endl;
    evalh << "   Number dTTH_0_0[" << nspec << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", dTTH_" << k << "_" << i << "[" << nspec << "]";
      }
    }
    evalh << ";" << endl;

    evalh << "   Number dYYYf_0_0[" << nop << "][" << nop << "][" << nop << "]["
          << nop << "], dYYTf_0_0[" << nop << "][" << nop << "][" << nop
          << "], dYTTf_0_0[" << nop << "][" << nop << "];" << endl
          << endl;

    evalh << "   //get derivatives" << endl;
    evalh << "   getThirdDerivative_f(T_0_0, Y_0_0, f_0_0, dYf_0_0, dTf_0_0, "
             "dYYf_0_0, dYTf_0_0, dTTf_0_0, dYYYf_0_0, dYYTf_0_0, dYTTf_0_0, "
             "H_0_0, dTH_0_0, dTTH_0_0, Yres_0_0, dYYres_0_0);"
          << endl;
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << "   getSecondDerivative_f(T_" << k << "_" << i << ", Y_" << k
              << "_" << i << ", f_" << k << "_" << i << ", dYf_" << k << "_"
              << i << ", dTf_" << k << "_" << i << ", dYYf_" << k << "_" << i
              << ", dYTf_" << k << "_" << i << ", dTTf_" << k << "_" << i
              << ", H_" << k << "_" << i << ", dTH_" << k << "_" << i
              << ", dTTH_" << k << "_" << i << ", Yres_" << k << "_" << i
              << ", dYYres_" << k << "_" << i << ");" << endl;
      }
    }
    evalh << endl;

    evalh << "   //build HessF" << endl;
    evalh << "   Number HessF[" << NOP + 1 << "][" << NOP + 1 << "];" << endl;
    for (int m = 0; m < NOP; ++m) {
      for (int k = 0; k < NOP; ++k) {
        evalh << "   HessF[" << m << "][" << k << "] = 0.0;" << endl;
        for (int i = 0; i < nop; ++i) {
          evalh << "   HessF[" << m << "][" << k << "] += 2.0 * ( ( 0.0";
          for (int s = 0; s < nop; ++s) {
            evalh << " + dYYf_0_0[" << i << "][" << s << "][" << k
                  << "] * f_0_0[" << s << "] + dYf_0_0[" << i << "][" << s
                  << "] * dYf_0_0[" << s << "][" << k << "]";
          }
          evalh << ") * ( 0.0";
          for (int s = 0; s < nop; ++s) {
            evalh << " + dYYf_0_0[" << i << "][" << s << "][" << m
                  << "] * f_0_0[" << s << "] + dYf_0_0[" << i << "][" << s
                  << "] * dYf_0_0[" << s << "][" << m << "]";
          }
          evalh << ") + (0.0";
          for (int s = 0; s < nop; ++s) {
            evalh << " + dYf_0_0[" << i << "][" << s << "] * f_0_0[" << s
                  << "]";
          }
          evalh << ") * ( 0.0";
          for (int s = 0; s < nop; ++s) {
            evalh << " + dYYYf_0_0[" << i << "][" << s << "][" << m << "][" << k
                  << "] * f_0_0[" << s << "] + dYYf_0_0[" << i << "][" << s
                  << "][" << m << "] * dYf_0_0[" << s << "][" << k
                  << "] + dYYf_0_0[" << i << "][" << s << "][" << k
                  << "] * dYf_0_0[" << s << "][" << m << "] + dYYf_0_0[" << s
                  << "][" << m << "][" << k << "] * dYf_0_0[" << i << "][" << s
                  << "]";
          }
          evalh << "));" << endl;
        }
        evalh << endl;
      }
    }

    for (int m = 0; m < NOP; ++m) {
      evalh << "   HessF[" << NOP << "][" << m << "] = 0.0;" << endl;
      for (int i = 0; i < nop; ++i) {
        evalh << "   HessF[" << NOP << "][" << m << "] += 2.0 * ( ( 0.0";
        for (int s = 0; s < nop; ++s) {
          evalh << " + dYTf_0_0[" << i << "][" << s << "] * f_0_0[" << s
                << "] + dYf_0_0[" << i << "][" << s << "] * dTf_0_0[" << s
                << "]";
        }
        evalh << ") * ( 0.0";
        for (int s = 0; s < nop; ++s) {
          evalh << " + dYYf_0_0[" << i << "][" << s << "][" << m << "] * f_0_0["
                << s << "] + dYf_0_0[" << i << "][" << s << "] * dYf_0_0[" << s
                << "][" << m << "]";
        }
        evalh << ") + (0.0";
        for (int s = 0; s < nop; ++s) {
          evalh << " + dYf_0_0[" << i << "][" << s << "] * f_0_0[" << s << "]";
        }
        evalh << ") * ( 0.0";
        for (int s = 0; s < nop; ++s) {
          evalh << " + dYYTf_0_0[" << i << "][" << s << "][" << m
                << "] * f_0_0[" << s << "] + dYYf_0_0[" << i << "][" << s
                << "][" << m << "] * dTf_0_0[" << s << "] + dYTf_0_0[" << i
                << "][" << s << "] * dYf_0_0[" << s << "][" << m
                << "] + dYTf_0_0[" << s << "][" << m << "] * dYf_0_0[" << i
                << "][" << s << "]";
        }
        evalh << "));" << endl;
      }
      evalh << "   HessF[" << m << "][" << NOP << "] = HessF[" << NOP << "]["
            << m << "];" << endl;
      evalh << endl;
    }

    evalh << "   HessF[" << NOP << "][" << NOP << "] = 0.0;" << endl;
    for (int i = 0; i < nop; ++i) {
      evalh << "   HessF[" << NOP << "][" << NOP << "] += 2.0 * ( ( 0.0";
      for (int s = 0; s < nop; ++s) {
        evalh << " + dYTf_0_0[" << i << "][" << s << "] * f_0_0[" << s
              << "] + dYf_0_0[" << i << "][" << s << "] * dTf_0_0[" << s << "]";
      }
      evalh << ") * ( 0.0";
      for (int s = 0; s < nop; ++s) {
        evalh << " + dYTf_0_0[" << i << "][" << s << "] * f_0_0[" << s
              << "] + dYf_0_0[" << i << "][" << s << "] * dTf_0_0[" << s << "]";
      }
      evalh << ") + (0.0";
      for (int s = 0; s < nop; ++s) {
        evalh << " + dYf_0_0[" << i << "][" << s << "] * f_0_0[" << s << "]";
      }
      evalh << ") * ( 0.0";
      for (int s = 0; s < nop; ++s) {
        evalh << " + dYTTf_0_0[" << i << "][" << s << "] * f_0_0[" << s
              << "] + 2*dYTf_0_0[" << i << "][" << s << "] * dTf_0_0[" << s
              << "] + dTTf_0_0[" << s << "] * dYf_0_0[" << i << "][" << s
              << "]";
      }
      evalh << "));" << endl;
    }

    evalh << endl << endl;

    evalh << "   //mulitply with scaling factor and obj_factor" << endl;
    for (int m = 0; m < NOP + 1; ++m) {
      for (int k = 0; k < NOP + 1; ++k) {
        evalh << "   HessF[" << m << "][" << k << "] *= (scale*obj_factor);"
              << endl;
      }
    }
    evalh << endl;

    evalh
        << "   //add second order derivatives of enthalpy conservation to HessF"
        << endl;
    for (int m = 0; m < NOP; ++m) {
      evalh << "   HessF[" << NOP << "][" << m << "] += lambda["
            << NSTAGES * NOP << "] * (1/Ms[" << Iop[m] - 1 << "] * dTH_0_0["
            << Iop[m] - 1 << "]";
      for (int i = 0; i < nnop; ++i) {
        evalh << " + dTH_0_0[" << Inop[i] - 1 << "]/Ms[" << Inop[i] - 1
              << "] * dYYres_0_0[" << i << "][" << m << "]";
      }
      evalh << ");" << endl;
      evalh << "   HessF[" << m << "][" << NOP << "] += lambda["
            << NSTAGES * NOP << "] * (1/Ms[" << Iop[m] - 1 << "] * dTH_0_0["
            << Iop[m] - 1 << "]";
      for (int i = 0; i < nnop; ++i) {
        evalh << " + dTH_0_0[" << Inop[i] - 1 << "]/Ms[" << Inop[i] - 1
              << "] * dYYres_0_0[" << i << "][" << m << "]";
      }
      evalh << ");" << endl;
      evalh << endl;
    }

    evalh << "   HessF[" << NOP << "][" << NOP << "] += lambda["
          << NSTAGES * NOP << "] * (";
    for (int i = 0; i < nop; ++i) {
      evalh << " + dTTH_0_0[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
            << "] * Y_0_0[" << i << "]";
    }
    for (int i = 0; i < nnop; ++i) {
      evalh << " + dTTH_0_0[" << Inop[i] - 1 << "]/Ms[" << Inop[i] - 1
            << "] * Yres_0_0[" << i << "]";
    }
    evalh << ");" << endl;
    evalh << endl;

    int valuesH = 0;
    evalh << "   //create first block" << endl;
    for (int i = 0; i < NOP + 1; ++i) {
      for (int j = 0; j < NOP + 1; ++j) {
        evalh << "   values[" << valuesH << "] = HessF[" << i << "][" << j
              << "];" << endl;
        valuesH++;
      }
    }
    evalh << endl;

    evalh << std::setprecision(20);
    int offset = 0, soffset = 1;

    for (int nit = 0; nit <= NINT; ++nit) {

      for (int l = 1; l <= NSTAGES; ++l) {
        evalh << "   //generate Block_" << nit << "_" << l << endl;
        evalh << "   Number Block_" << nit << "_" << l << "[" << NOP + 1 << "]["
              << NOP + 1 << "];" << endl;
        for (int s = 0; s < NOP; ++s) {
          for (int m = 0; m < NOP; ++m) {
            evalh << "   Block_" << nit << "_" << l << "[" << s << "][" << m
                  << "] = -h* (0.0 ";
            for (int i = 0; i < NSTAGES; ++i) {
              for (int k = 0; k < NOP; ++k) {
                evalh << " + (" << A[i][l - 1] << ") * lambda["
                      << offset + i * NOP + k << "] * dYYf_" << nit << "_" << l
                      << "[" << k << "][" << s << "][" << m << "]";
              }
            }
            evalh << ");" << endl;
          }
        }
        evalh << endl;
        for (int s = 0; s < NOP; ++s) {
          evalh << "   Block_" << nit << "_" << l << "[" << s << "][" << NOP
                << "] = -h* (0.0 ";
          for (int i = 0; i < NSTAGES; ++i) {
            for (int k = 0; k < NOP; ++k) {
              evalh << " + (" << A[i][l - 1] << ") * lambda["
                    << offset + i * NOP + k << "] * dYTf_" << nit << "_" << l
                    << "[" << k << "][" << s << "]";
            }
          }
          evalh << ") + lambda[" << offset + NOP * NSTAGES + soffset + l - 1
                << "] * (1/Ms[" << Iop[s] - 1 << "] * dTH_" << nit << "_" << l
                << "[" << Iop[s] - 1 << "]";
          for (int i = 0; i < nnop; ++i) {
            evalh << " + dTH_" << nit << "_" << l << "[" << Inop[i] - 1
                  << "]/Ms[" << Inop[i] - 1 << "] * dYYres_" << nit << "_" << l
                  << "[" << i << "][" << s << "]";
          }
          evalh << "); Block_" << nit << "_" << l << "[" << NOP << "][" << s
                << "] = Block_" << nit << "_" << l << "[" << s << "][" << NOP
                << "];" << endl;
        }
        evalh << endl;

        evalh << "   Block_" << nit << "_" << l << "[" << NOP << "][" << NOP
              << "] = -h* (0.0 ";
        for (int i = 0; i < NSTAGES; ++i) {
          for (int k = 0; k < NOP; ++k) {
            evalh << " + (" << A[i][l - 1] << ") * lambda["
                  << offset + i * NOP + k << "] * dTTf_" << nit << "_" << l
                  << "[" << k << "]";
          }
        }
        evalh << ") + lambda[" << offset + NOP * NSTAGES + soffset + l - 1
              << "] * (";
        for (int i = 0; i < nop; ++i) {
          evalh << " + dTTH_" << nit << "_" << l << "[" << Iop[i] - 1 << "]/Ms["
                << Iop[i] - 1 << "] * Y_" << nit << "_" << l << "[" << i << "]";
        }
        for (int i = 0; i < nnop; ++i) {
          evalh << " + dTTH_" << nit << "_" << l << "[" << Inop[i] - 1
                << "]/Ms[" << Inop[i] - 1 << "] * Yres_" << nit << "_" << l
                << "[" << i << "]";
        }
        evalh << ");" << endl;
        evalh << endl;

        evalh << "   //set block values" << endl;
        for (int i = 0; i < NOP + 1; ++i) {
          for (int j = 0; j < NOP + 1; ++j) {
            evalh << "   values[" << valuesH << "] = Block_" << nit << "_" << l
                  << "[" << i << "][" << j << "];" << endl;
            valuesH++;
          }
        }
        evalh << endl;
      }
      offset += NSTAGES * (NOP + 1);
      if (nit == 0) {
        offset++;
        soffset = 0;
      }
    }

    evalh << "   } // else-block of (values == NULL)" << endl;
  }
  evalh << "   return true;" << endl;
  evalh << "} //eval_h" << endl;
  evalh.close();
}

void generateRates(vector<double> A, vector<double> b, vector<double> Ea,
                   vector<string> species, vector<vector<int>> nuprime,
                   vector<vector<int>> nu2prime, vector<double> Ms,
                   vector<int> forwardReactions, vector<vector<double>> nasa,
                   vector<double> switchingPoints, string format,
                   string filename) {

  // get problem dimensions
  int nreac = A.size();
  int nspec = species.size();

  // generate nu
  vector<vector<int>> nu(nspec, vector<int>(nreac, 0));
  for (int i = 0; i < nu.size(); ++i) {
    for (int k = 0; k < nu[0].size(); ++k) {
      nu[i][k] = nu2prime[i][k] - nuprime[i][k];
    }
  }

  // get time for time stamp
  time_t t;
  time(&t);

  if (format.compare("python") == 0) {
    ofstream rates("rates.py");
    rates << std::setprecision(15);
    rates << "# Autogenerated file on " << ctime(&t);
    rates << "# rates.py" << endl;
    rates
        << "#    Description: Calculates the forward and reverse reaction rates"
        << endl;
    rates << "#                 based on arrhenius law and thermodynamics as "
             "well as"
          << endl;
    rates << "#                 required derivatives for" << endl;
    rates << "#                 mechanism: " << filename << "." << endl;
    rates << "#    Input:  T - temperature." << endl;
    rates << "#    Output: kf - forward rates." << endl;
    rates << "#            kr - reverse rates." << endl;
    rates << "#            dTkf - first derivative of forward rates w.r.t. "
             "temperature."
          << endl;
    rates << "#            dTkr - first derivative of reverse rates w.r.t. "
             "temperature."
          << endl;
    rates << "#            d2Tkf - second derivative of forward rates w.r.t. "
             "temperature."
          << endl;
    rates << "#            d2Tkr - second derivative of reverse rates w.r.t. "
             "temperature."
          << endl;
    rates << "import numpy as np" << endl;
    rates << "def rates(T):" << endl << endl;

    rates << "\t## Preliminaries" << endl;
    rates << "\tkf = np.zeros(" << nreac << ")" << endl;
    rates << "\tkr = np.zeros(" << nreac << ")" << endl;
    rates << "\tKp = np.zeros(" << nreac << ")" << endl;
    rates << "\tKc = np.zeros(" << nreac << ")" << endl;
    rates << "\tdeltaH = np.zeros(" << nreac << ") # molar reaction enthalpy"
          << endl;
    rates << "\tdeltaS = np.zeros(" << nreac << ") # molar reaction entropy"
          << endl;
    rates << "\tdTkf = np.zeros(" << nreac << ")" << endl;
    rates << "\tdTkr = np.zeros(" << nreac << ")" << endl;
    rates << "\tdTKp = np.zeros(" << nreac << ")" << endl;
    rates << "\tdTKc = np.zeros(" << nreac << ")" << endl;
    rates << "\tdTdeltaH = np.zeros(" << nreac << ")" << endl;
    rates << "\tdTdeltaS = np.zeros(" << nreac << ")" << endl;
    rates << "\td2Tkf = np.zeros(" << nreac << ")" << endl;
    rates << "\td2Tkr = np.zeros(" << nreac << ")" << endl;
    rates << "\td2TKp = np.zeros(" << nreac << ")" << endl;
    rates << "\td2TKc = np.zeros(" << nreac << ")" << endl;
    rates << "\td2TdeltaH = np.zeros(" << nreac << ")" << endl;
    rates << "\td2TdeltaS = np.zeros(" << nreac << ")" << endl;
    rates << "\tgamma  = 20 # transition parameter" << endl;
    rates << "\tR = 8.3144598" << endl;
    rates << "\tp0 = 100000 # standard pressure = 1 bar = 100000 Pa" << endl;
    rates << "\tA = np.array([";
    for (int i = 0; i < nreac; ++i) {
      rates << std::setprecision(15) << A[i] << ",";
    }
    rates << "])" << endl;
    rates << "\tb = np.array([";
    for (int i = 0; i < nreac; ++i) {
      rates << b[i] << ",";
    }
    rates << "])" << endl;
    rates << "\tEa = np.array([";
    for (int i = 0; i < nreac; ++i) {
      rates << Ea[i] << ",";
    }
    rates << "])" << endl;

    // generating nasa
    rates << "\tnasa = np.array([";
    for (int i = 0; i < nspec; ++i) {
      if (i == 0) {
        rates << "[";
      } else {
        rates << "\t[";
      }
      for (int k = 0; k < 14; ++k) {
        rates << nasa[i][k] << ",";
      }
      rates << "]," << endl;
    }
    rates << "\t]) # coefficients for nasa polynomials - each line: "
             "[a1_low,...,a7_low,a1_high,..,a7_high]"
          << endl;

    // generating switching points
    rates << "\tT_sw = np.array([";
    for (int k = 0; k < nspec; ++k) {
      rates << switchingPoints[k] << ",";
    }
    rates << "]) # switching points between branches" << endl;

    // generating kf
    rates << endl << "\t# Calculate forward rates" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "\tkf[" << i << "] = A[" << i << "] * T**(b[" << i
            << "]) * np.exp(-Ea[" << i << "]/(R*T))" << endl;
    }

    // generating Hbar_{low,high}, Sbar_{low,high}
    rates << endl << "\t# calculate H_{low,high}, S_{low,high}" << endl;
    rates << "\tH_low = R*(nasa[:,0]*T + nasa[:,1]/2*T**2 + nasa[:,2]/3*T**3 + "
             "nasa[:,3]/4*T**4 + nasa[:,4]/5*T**5 + nasa[:,5])"
          << endl;
    rates << "\tH_high = R*(nasa[:,7]*T + nasa[:,8]/2*T**2 + nasa[:,9]/3*T**3 "
             "+ nasa[:,10]/4*T**4 + nasa[:,11]/5*T**5 + nasa[:,12])"
          << endl;
    rates
        << "\tS_low  = R*(nasa[:,0]*np.log(T) + nasa[:,1]*T + nasa[:,2]/2*T**2 "
           "+ nasa[:,3]/3*T**3 + nasa[:,4]/4*T**4 + nasa[:,6])"
        << endl;
    rates
        << "\tS_high = R*(nasa[:,7]*np.log(T) + nasa[:,8]*T + nasa[:,9]/2*T**2 "
           "+ nasa[:,10]/3*T**3 + nasa[:,11]/4*T**4 + nasa[:,13])"
        << endl;

    // generating Hbar, Sbar
    rates << "\t# calculate Hbar, Sbar" << endl;
    rates << "\tsigma = 1/2*np.tanh(gamma*(T-T_sw)) + 1/2" << endl;
    rates << "\tHbar = (1-sigma)*H_low + sigma*H_high" << endl;
    rates << "\tSbar = (1-sigma)*S_low + sigma*S_high" << endl;

    // generating molar reaction enthalpy, entropy
    rates << "\t# calculate deltaH, deltaS" << endl;
    for (int r = 0; r < nreac; ++r) {
      rates << "\tdeltaH[" << r << "] = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * Hbar[" << s << "]";
        }
      }
      rates << endl << "\tdeltaS[" << r << "] = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * Sbar[" << s << "]";
        }
      }
      rates << endl;
    }

    // generating Kp, Kc
    rates << endl << "\t# Calculate equilibrium rates" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "\tKp[" << i << "] = np.exp(deltaS[" << i << "]/R-deltaH[" << i
            << "]/(R*T))" << endl;
      int nur = 0;
      for (int s = 0; s < nspec; ++s) {
        nur = nur + nu[s][i];
      }
      rates << "\tKc[" << i << "] = Kp[" << i << "] * (p0/(R*T))**(" << nur
            << ")" << endl;
    }

    // generating kr
    rates << endl << "\t# Calculate reverse rates" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "\tkr[" << i << "] = kf[" << i << "]/Kc[" << i << "]" << endl;
    }

    // generating dTkf
    rates << endl << "\t# Calculate derivative of kf" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "\tdTkf[" << i << "] = A[" << i << "]*b[" << i << "]*T**(b[" << i
            << "]-1)*np.exp(-Ea[" << i << "]/(R*T)) + A[" << i << "]*Ea[" << i
            << "]/R*T**(b[" << i << "]-2)*np.exp(-Ea[" << i << "]/(R*T))"
            << endl;
    }
    rates << endl;

    // generating dTHbar_{low,high}, Sbar_{low,high}
    rates << "\t# calculate dTH_{low,high}, dTS_{low,high}" << endl;
    rates << "\tdTH_low  = R*(nasa[:,0] + nasa[:,1]*T + nasa[:,2]*T**2 + "
             "nasa[:,3]*T**3 + nasa[:,4]*T**4)"
          << endl;
    rates << "\tdTH_high = R*(nasa[:,7] + nasa[:,8]*T + nasa[:,9]*T**2 + "
             "nasa[:,10]*T**3 + nasa[:,11]*T**4)"
          << endl;
    rates << "\tdTS_low  = R*(nasa[:,0]/T + nasa[:,1] + nasa[:,2]*T + "
             "nasa[:,3]*T**2 + nasa[:,4]*T**3)"
          << endl;
    rates << "\tdTS_high = R*(nasa[:,7]/T + nasa[:,8] + nasa[:,9]*T + "
             "nasa[:,10]*T**2 + nasa[:,11]*T**3)"
          << endl;

    // generating dTHbar, Sbar
    rates << "\t# calculate dTHbar, dTSbar" << endl;
    rates << "\tdTsigma = gamma/(2*np.cosh(gamma*(T-T_sw)))" << endl;
    rates << "\tdTHbar = (1-sigma)*dTH_low + sigma*dTH_high - dTsigma*H_low + "
             "dTsigma*H_high"
          << endl;
    rates << "\tdTSbar = (1-sigma)*dTS_low + sigma*dTS_high - dTsigma*S_low + "
             "dTsigma*S_high"
          << endl;

    // generating d/dT of molar reaction enthalpy, entropy
    rates << "\t# calculate dTdeltaH, dTdeltaS" << endl;
    for (int r = 0; r < nreac; ++r) {
      rates << "\tdTdeltaH[" << r << "] = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * dTHbar[" << s << "]";
        }
      }
      rates << endl << "\tdTdeltaS[" << r << "] = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * dTSbar[" << s << "]";
        }
      }
      rates << endl;
    }

    // generating d/dT of Kp
    rates << endl << "\t# Calculate d/dT of Kp" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "\tdTKp[" << i << "] = np.exp(deltaS[" << i << "]/R-deltaH[" << i
            << "]/(R*T)) * (1/R * dTdeltaS[" << i << "]  - (dTdeltaH[" << i
            << "]*T - deltaH[" << i << "])/(R*T**2))" << endl;
    }

    // generating d/dT of Kc
    rates << endl << "\t# Calculate d/dT of Kc" << endl;
    for (int i = 0; i < nreac; ++i) {
      int nur = 0;
      for (int s = 0; s < nspec; ++s) {
        nur = nur + nu[s][i];
      }
      rates << "\tdTKc[" << i << "] = dTKp[" << i << "] * (p0/(R*T))**(" << nur
            << ") - p0/(R*T**2)*Kp[" << i << "]*(" << nur << ")*(p0/(R*T))**("
            << nur - 1 << ")" << endl;
    }

    // generating dTkr
    rates << endl << "\t#Calculate derivative of kr" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "\tdTkr[" << i << "] = (dTkf[" << i << "]*Kc[" << i << "]-kf["
            << i << "]*dTKc[" << i << "])/(Kc[" << i << "]**2)" << endl;
    }

    // generating d2Tkf
    rates << endl << "\t# Calculate 2nd order derivative of kf" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "\td2Tkf[" << i << "] =  ( Ea[" << i << "]*(2*b[" << i
            << "]-2)/R*T**(b[" << i << "]-3) + ( b[" << i << "]*(b[" << i
            << "]-1) + (Ea[" << i << "]/(R*T))**2) * T**(b[" << i
            << "]-2) ) * A[" << i << "]*np.exp(-Ea[" << i << "]/(R*T))" << endl;
    }
    rates << endl;

    // generating d2THbar_{low,high}, d2TSbar_{low,high}
    rates << "\t# calculate d2TH_{low,high}, d2TS_{low,high}" << endl;
    rates << "\td2TH_low  = R*(nasa[:,1] + 2*nasa[:,2]*T + 3*nasa[:,3]*T**2 + "
             "4*nasa[:,4]*T**3)"
          << endl;
    rates << "\td2TH_high = R*(nasa[:,8] + 2*nasa[:,9]*T + 3*nasa[:,10]*T**2 + "
             "4*nasa[:,11]*T**3)"
          << endl;
    rates << "\td2TS_low  = R*(-nasa[:,0]/(T**2) + nasa[:,2] + 2*nasa[:,3]*T + "
             "3*nasa[:,4]*T**2)"
          << endl;
    rates << "\td2TS_high = R*(-nasa[:,7]/(T**2) + nasa[:,9] + 2*nasa[:,10]*T "
             "+ 3*nasa[:,11]*T**2)"
          << endl;

    // generating d2THbar, d2TSbar
    rates << "\t# calculate d2THbar, d2TSbar" << endl;
    rates << "\td2Tsigma = -gamma**2*np.tanh(gamma*(T-T_sw)) * "
             "(1-np.tanh(gamma*(T-T_sw))**2)"
          << endl;
    rates
        << "\td2THbar = (1-sigma)*d2TH_low -2*dTsigma*dTH_low - d2Tsigma*H_low "
           "+ sigma*d2TH_high + 2*dTsigma*dTH_high + d2Tsigma*H_high"
        << endl;
    rates
        << "\td2TSbar = (1-sigma)*d2TS_low -2*dTsigma*dTS_low - d2Tsigma*S_low "
           "+ sigma*d2TS_high + 2*dTsigma*dTS_high + d2Tsigma*S_high"
        << endl;

    // generating d2/d2T of molar reaction enthalpy, entropy
    rates << "\t# calculate d2TdeltaH, d2TdeltaS" << endl;
    for (int r = 0; r < nreac; ++r) {
      rates << "\td2TdeltaH[" << r << "] = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * d2THbar[" << s << "]";
        }
      }
      rates << endl << "\td2TdeltaS[" << r << "] = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * d2TSbar[" << s << "]";
        }
      }
      rates << endl;
    }

    // generating d2/d2T of Kp
    rates << endl << "\t# Calculate d2/d2T of Kp" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "\td2TKp[" << i << "] = 1/R*np.exp(deltaS[" << i << "]/R-deltaH["
            << i << "]/(R*T)) * ( 1/R * (dTdeltaS[" << i
            << "]  - 1/T * dTdeltaH[" << i << "] + deltaH[" << i
            << "]/(T*T))**2 + d2TdeltaS[" << i << "] + 2/(T*T)* dTdeltaH[" << i
            << "] - 1/T*d2TdeltaH[" << i << "] - 2/(T*T*T)*deltaH[" << i << "])"
            << endl;
    }

    // generating d2/d2T of Kc
    rates << endl << "\t#Calculate d2/d2T of Kc" << endl;
    for (int i = 0; i < nreac; ++i) {
      int nur = 0;
      for (int s = 0; s < nspec; ++s) {
        nur = nur + nu[s][i];
      }
      rates << "\td2TKc[" << i << "] = d2TKp[" << i << "] * (p0/(R*T))**("
            << nur << ")";
      if (nur != 0) {
        rates << "+ Kp[" << i << "] * (p0/R)**(" << nur << ") * (" << nur
              << ")*(" << nur + 1 << ")/T**(" << nur + 2 << ") - 2*(" << nur
              << ")/T**(" << nur + 1 << ") * dTKp[" << i << "]*(p0/R)**(" << nur
              << ")";
      }
      rates << endl;
    }

    // generating dTkr
    rates << endl << "\t# Calculate 2nd order derivative of kr" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "\td2Tkr[" << i << "] = ( (d2Tkf[" << i << "]*Kc[" << i
            << "]-kf[" << i << "]*d2TKc[" << i << "])*Kc[" << i
            << "]**2 - 2*Kc[" << i << "]*dTKc[" << i << "]*(dTkf[" << i
            << "]*Kc[" << i << "] - kf[" << i << "]*dTKc[" << i << "]) )/(Kc["
            << i << "]**4)" << endl;
    }

    // set reverse rates of each forward reaction to zero
    rates << endl
          << "\t# Set for each forward reaction the reverse rate and their "
             "derivatives to zero"
          << endl;
    for (int i = 0; i < forwardReactions.size(); ++i) {
      rates << "kr[" << forwardReactions[i] << "] = 0" << endl;
      rates << "dTkr[" << forwardReactions[i] << "] = 0" << endl;
      rates << "d2Tkr[" << forwardReactions[i] << "] = 0" << endl;
    }

    rates << endl;
    rates << "\treturn kf,kr,dTkf,dTkr,d2Tkf,d2Tkr" << endl;

    rates.close();
    /*
     *   Parse to c++ format.
     *
     *
     */

  } else if (format.compare("c++") == 0) {
    ofstream rates("rates.hpp");
    rates << "/* Autogenerated file on " << ctime(&t);
    rates << " *    Function which returns reaction rates and their "
             "derivatives based on arrhenius law and thermodynamics"
          << endl;
    rates << " *    Mechanism: " << filename << endl;
    rates << " */" << endl;
    rates << std::setprecision(15);
    rates << "void ammsockNLP::rates(Number T, Number kf[" << nreac
          << "],  Number kr[" << nreac << "], Number dTkf[" << nreac
          << "], Number dTkr[" << nreac << "], Number d2Tkf[" << nreac
          << "], Number d2Tkr[" << nreac << "], Number Hbar[" << nspec
          << "], Number dTHbar[" << nspec << "], Number d2THbar[" << nspec
          << "]) {" << endl
          << endl;

    rates << "   // Preliminaries" << endl;
    rates << "   int nreac = (int) " << nreac << ";" << endl;
    rates << "   int nspec = (int) " << nspec << ";" << endl;
    rates << "   Number A[nreac];      // preexponential coefficient" << endl;
    rates << "   Number b[nreac];      // exponent for T in arrhenius low"
          << endl;
    rates << "   Number Ea[nreac];     // activation energy in J" << endl;
    rates
        << "   Number H_low[nspec];  // standard molar enthalpy for low branche"
        << endl;
    rates << "   Number H_high[nspec]; // standard molar enthalpy for high "
             "branche"
          << endl;
    rates
        << "   Number S_low[nspec];  // standard molar entropy for low branche"
        << endl;
    rates
        << "   Number S_high[nspec]; // standard molar entropy for high branche"
        << endl;
    rates
        << "   Number Sbar[nspec];   // standard molar entropy for all branches"
        << endl;
    rates << "   Number deltaH[nreac]; // molar reaction enthalpy" << endl;
    rates << "   Number deltaS[nreac]; // molar reaction entropy" << endl;
    rates << "   Number Kp[nreac];" << endl;
    rates << "   Number Kc[nreac];" << endl;
    rates << "   Number dTH_low[nspec];" << endl;
    rates << "   Number dTH_high[nspec];" << endl;
    rates << "   Number dTS_low[nspec];" << endl;
    rates << "   Number dTS_high[nspec];" << endl;
    rates << "   Number dTSbar[nspec];" << endl;
    rates << "   Number dTdeltaH[nreac];" << endl;
    rates << "   Number dTdeltaS[nreac];" << endl;
    rates << "   Number dTKp[nreac];" << endl;
    rates << "   Number dTKc[nreac];" << endl;
    rates << "   Number d2TH_low[nspec];" << endl;
    rates << "   Number d2TH_high[nspec];" << endl;
    rates << "   Number d2TS_low[nspec];" << endl;
    rates << "   Number d2TS_high[nspec];" << endl;
    rates << "   Number d2TSbar[nspec];" << endl;
    rates << "   Number d2TdeltaH[nreac];" << endl;
    rates << "   Number d2TdeltaS[nreac];" << endl;
    rates << "   Number d2TKp[nreac];" << endl;
    rates << "   Number d2TKc[nreac];" << endl;
    rates << "   Number T_sw[nspec];" << endl;
    rates << "   Number nasa[nspec][14];" << endl;
    rates << "   Number gamma  = 20; // transition parameter" << endl;
    rates << "   Number R = 8.3144598;" << endl;
    rates << "   Number p0 = 100000; // standard pressure" << endl;

    rates << endl << "   //generating A" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   A[" << i << "] = " << A[i] << "; " << endl;
    }

    rates << endl << "   //generating b" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   b[" << i << "] = " << b[i] << "; " << endl;
    }

    rates << endl << "   //generating Ea" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   Ea[" << i << "] = " << Ea[i] << "; " << endl;
    }

    // generating nasa
    rates << endl
          << "   //coefficients nasa polynomials - each row: "
             "[a1_low,...,a7_low,a1_high,..,a7_high]";
    for (int i = 0; i < nspec; ++i) {
      rates << "   // coefficients for specie " << i + 1 << endl;
      for (int k = 0; k < 14; ++k) {
        rates << "   nasa[" << i << "][" << k << "] = " << nasa[i][k] << ";"
              << endl;
      }
      rates << endl;
    }

    // generating switching points
    rates
        << "   //generating switching points for different temperature branches"
        << endl;
    for (int k = 0; k < nspec; ++k) {
      rates << "   T_sw[" << k << "] = " << switchingPoints[k] << ";" << endl;
    }

    // generating kf
    rates << endl << endl << "   //calculate forward rates" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   kf[" << i << "] = A[" << i << "] * pow(T,b[" << i
            << "]) * exp(-Ea[" << i << "]/(R*T));" << endl;
    }

    // generating Hbar_{low,high}, Sbar_{low,high}
    rates << endl << "   //calculate H_{low,high}, S_{low,high}" << endl;
    rates << "   for (int i = 0; i < nspec; ++i) {" << endl;
    rates << "      H_low[i]  = R*(nasa[i][0]*T + nasa[i][1]/2.0*pow(T,2) + "
             "nasa[i][2]/3.0*pow(T,3) + nasa[i][3]/4.0*pow(T,4) + "
             "nasa[i][4]/5.0*pow(T,5) + nasa[i][5]);"
          << endl;
    rates << "      H_high[i] = R*(nasa[i][7]*T + nasa[i][8]/2.0*pow(T,2) + "
             "nasa[i][9]/3.0*pow(T,3) + nasa[i][10]/4.0*pow(T,4) + "
             "nasa[i][11]/5.0*pow(T,5) + nasa[i][12]);"
          << endl;
    rates << "      S_low[i]  = R*(nasa[i][0]*log(T) + nasa[i][1]*T + "
             "nasa[i][2]/2.0*pow(T,2) + nasa[i][3]/3.0*pow(T,3) + "
             "nasa[i][4]/4.0*pow(T,4) + nasa[i][6]);"
          << endl;
    rates << "      S_high[i] = R*(nasa[i][7]*log(T) + nasa[i][8]*T + "
             "nasa[i][9]/2.0*pow(T,2) + nasa[i][10]/3.0*pow(T,3) + "
             "nasa[i][11]/4.0*pow(T,4) + nasa[i][13]);"
          << endl;
    rates << "   }" << endl;

    // generating Hbar, Sbar
    rates << endl << "   //calculate Hbar, Sbar" << endl;
    rates << "   Number sigma = 0.0;" << endl;
    rates << "   for (int i = 0; i < nspec; ++i) {" << endl;
    rates << "      sigma = 1/2.0*tanh(gamma*(T-T_sw[i])) + 1/2.0;" << endl;
    rates << "      Hbar[i] = (1-sigma)*H_low[i] + sigma*H_high[i];" << endl;
    rates << "      Sbar[i] = (1-sigma)*S_low[i] + sigma*S_high[i];" << endl;
    rates << "   }" << endl;

    // generating molar reaction enthalpy, entropy
    rates << endl << "   //calculate deltaH, deltaS" << endl;
    for (int r = 0; r < nreac; ++r) {
      rates << "   deltaH[" << r << "] = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * Hbar[" << s << "]";
        }
      }
      rates << ";" << endl << "   deltaS[" << r << "] = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * Sbar[" << s << "]";
        }
      }
      rates << ";" << endl;
    }

    // generating K_p and K_c
    rates << endl << endl << "   //calculate equilibrium rates" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   Kp[" << i << "] = exp(deltaS[" << i << "]/R-deltaH[" << i
            << "]/(R*T));" << endl;
      int nur = 0;
      for (int s = 0; s < nspec; ++s) {
        nur = nur + nu[s][i];
      }
      rates << "   Kc[" << i << "] = Kp[" << i << "] * pow(p0/(R*T)," << nur
            << ");" << endl;
    }

    // generating kr
    rates << endl << endl << "   //calculate reverse rates" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   kr[" << i << "] = kf[" << i << "]/Kc[" << i << "];" << endl;
    }

    // generating dTkf
    rates << endl << "   // Calculate derivative of kf" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   dTkf[" << i << "] = A[" << i << "]*b[" << i << "]*pow(T,b["
            << i << "]-1)*exp(-Ea[" << i << "]/(R*T)) + A[" << i << "]*Ea[" << i
            << "]/R*pow(T,b[" << i << "]-2)*exp(-Ea[" << i << "]/(R*T));"
            << endl;
    }
    rates << endl;

    // generating dTHbar_{low,high}, dTSbar_{low,high}
    rates << "   // calculate dTH_{low,high}, dTS_{low,high}" << endl;
    rates << "   for (int i=0; i <" << nspec << "; ++i) {" << endl;
    rates
        << "         dTH_low[i]  = R*(nasa[i][0]   + nasa[i][1]*T + "
           "nasa[i][2]*pow(T,2) + nasa[i][3] *pow(T,3) + nasa[i][4] *pow(T,4));"
        << endl;
    rates
        << "         dTH_high[i] = R*(nasa[i][7]   + nasa[i][8]*T + "
           "nasa[i][9]*pow(T,2) + nasa[i][10]*pow(T,3) + nasa[i][11]*pow(T,4));"
        << endl;
    rates
        << "         dTS_low[i]  = R*(nasa[i][0]/T + nasa[i][1]   + "
           "nasa[i][2]*T        + nasa[i][3] *pow(T,2) + nasa[i][4] *pow(T,3));"
        << endl;
    rates
        << "         dTS_high[i] = R*(nasa[i][7]/T + nasa[i][8]   + "
           "nasa[i][9]*T        + nasa[i][10]*pow(T,2) + nasa[i][11]*pow(T,3));"
        << endl;
    rates << "   }" << endl << endl;

    // generating dTHbar, dTSbar
    rates << "   // calculate dTHbar, dTSbar" << endl;
    rates << "   Number dTsigma = 0.0;" << endl;
    rates << "   for (int i=0; i <" << nspec << "; ++i) {" << endl;
    rates << "      sigma = 1.0/2*tanh(gamma*(T-T_sw[i])) + 1/2.0;" << endl;
    rates << "      dTsigma = gamma/(2*cosh(gamma*(T-T_sw[i])));" << endl;
    rates << "      dTHbar[i] = (1-sigma)*dTH_low[i] + sigma*dTH_high[i] - "
             "dTsigma*H_low[i] + dTsigma*H_high[i];"
          << endl;
    rates << "      dTSbar[i] = (1-sigma)*dTS_low[i] + sigma*dTS_high[i] - "
             "dTsigma*S_low[i] + dTsigma*S_high[i];"
          << endl;
    rates << "   }" << endl << endl;

    // generating d/dT of molar reaction enthalpy, entropy
    rates << "   // calculate dTdeltaH, dTdeltaS" << endl;
    for (int r = 0; r < nreac; ++r) {
      rates << "   dTdeltaH[" << r << "] = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * dTHbar[" << s << "]";
        }
      }
      rates << ";" << endl << "   dTdeltaS[" << r << "] = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * dTSbar[" << s << "]";
        }
      }
      rates << ";" << endl;
    }

    // generating d/dT of Kp
    rates << endl << "   // Calculate d/dT of Kp" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   dTKp[" << i << "] = exp(deltaS[" << i << "]/R-deltaH[" << i
            << "]/(R*T)) * (1/R * dTdeltaS[" << i << "]  - (dTdeltaH[" << i
            << "]*T - deltaH[" << i << "])/(R*T*T));" << endl;
    }

    // generating d/dT of Kc
    rates << endl << "   // Calculate d/dT of Kc" << endl;
    for (int i = 0; i < nreac; ++i) {
      int nur = 0;
      for (int s = 0; s < nspec; ++s) {
        nur = nur + nu[s][i];
      }
      rates << "   dTKc[" << i << "] = dTKp[" << i << "] * pow(p0/(R*T)," << nur
            << ") - p0/(R*T*T)*Kp[" << i << "]*(" << nur << ")*pow(p0/(R*T),"
            << nur - 1 << ");" << endl;
    }

    // generating dTkr
    rates << endl << "   // Calculate derivative of kr" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   dTkr[" << i << "] = (dTkf[" << i << "]*Kc[" << i << "]-kf["
            << i << "]*dTKc[" << i << "])/pow(Kc[" << i << "],2);" << endl;
    }

    /*
     *   Calculate 2nd order derivatives
     */

    // generating d2Tkf
    rates << endl << "   // Calculate 2nd derivative of kf" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   d2Tkf[" << i << "] = ( Ea[" << i << "]*(2*b[" << i
            << "]-2)/R*pow(T,b[" << i << "]-3) + ( b[" << i << "]*(b[" << i
            << "]-1) + pow(Ea[" << i << "]/(R*T),2) )*pow(T,b[" << i
            << "]-2) ) * A[" << i << "]*exp(-Ea[" << i << "]/(R*T));" << endl;
    }
    rates << endl;

    // generating d2THbar_{low,high}, d2TSbar_{low,high}
    rates << "   // calculate d2TH_{low,high}, d2TS_{low,high}" << endl;
    rates << "   for (int i=0; i <" << nspec << "; ++i) {" << endl;
    rates << "         d2TH_low[i]  = R*(nasa[i][1] + 2*nasa[i][2]*T + "
             "3*nasa[i][3] *pow(T,2) + 4*nasa[i][4] *pow(T,3));"
          << endl;
    rates << "         d2TH_high[i] = R*(nasa[i][8] + 2*nasa[i][9]*T + "
             "3*nasa[i][10]*pow(T,2) + 4*nasa[i][11]*pow(T,3));"
          << endl;
    rates << "         d2TS_low[i]  = R*(-nasa[i][0]/(T*T) + nasa[i][2] + "
             "2*nasa[i][3]*T  + 3*nasa[i][4]*pow(T,2));"
          << endl;
    rates << "         d2TS_high[i] = R*(-nasa[i][7]/(T*T) + nasa[i][9] + "
             "2*nasa[i][10]*T + 3*nasa[i][11]*pow(T,2));"
          << endl;
    rates << "   }" << endl << endl;

    // generating d2THbar, d2TSbar
    rates << "   // calculate dTHbar, dTSbar" << endl;
    rates << "   Number d2Tsigma = 0.0;" << endl;
    rates << "   for (int i=0; i <" << nspec << "; ++i) {" << endl;
    rates << "      sigma = 1.0/2*tanh(gamma*(T-T_sw[i])) + 1/2.0;" << endl;
    rates << "      dTsigma = gamma/(2*cosh(gamma*(T-T_sw[i])));" << endl;
    rates << "      d2Tsigma = "
             "-gamma*gamma*tanh(gamma*(T-T_sw[i]))*(1-tanh(gamma*(T-T_sw[i]))*"
             "tanh(gamma*(T-T_sw[i])));"
          << endl;
    rates << "      d2THbar[i] = (1-sigma)*d2TH_low[i] -2*dTsigma*dTH_low[i] - "
             "d2Tsigma*H_low[i] + sigma*d2TH_high[i] + 2*dTsigma*dTH_high[i] + "
             "d2Tsigma*H_high[i];"
          << endl;
    rates << "      d2TSbar[i] = (1-sigma)*d2TS_low[i] -2*dTsigma*dTS_low[i] - "
             "d2Tsigma*S_low[i] + sigma*d2TS_high[i] + 2*dTsigma*dTS_high[i] + "
             "d2Tsigma*S_high[i];"
          << endl;
    rates << "   }" << endl << endl;

    // generating d2/d2T of molar reaction enthalpy, entropy
    rates << "   // calculate dTdeltaH, dTdeltaS" << endl;
    for (int r = 0; r < nreac; ++r) {
      rates << "   d2TdeltaH[" << r << "] = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * d2THbar[" << s << "]";
        }
      }
      rates << ";" << endl << "   d2TdeltaS[" << r << "] = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * d2TSbar[" << s << "]";
        }
      }
      rates << ";" << endl;
    }

    // generating d2/d2T of Kp
    rates << endl << "   // Calculate d2/d2T of Kp" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   d2TKp[" << i << "] = 1/R*exp(deltaS[" << i << "]/R-deltaH["
            << i << "]/(R*T)) * ( 1/R * pow(dTdeltaS[" << i
            << "]  - 1/T * dTdeltaH[" << i << "] + deltaH[" << i
            << "]/(T*T),2) + d2TdeltaS[" << i << "] + 2/(T*T)* dTdeltaH[" << i
            << "] - 1/T*d2TdeltaH[" << i << "] - 2/(T*T*T)*deltaH[" << i
            << "]);" << endl;
    }

    // generating d2/d2T of Kc
    rates << endl << "   // Calculate d2/d2T of Kc" << endl;
    for (int i = 0; i < nreac; ++i) {
      int nur = 0;
      for (int s = 0; s < nspec; ++s) {
        nur = nur + nu[s][i];
      }
      rates << "   d2TKc[" << i << "] = d2TKp[" << i << "] * pow(p0/(R*T),"
            << nur << ")";
      if (nur != 0) {
        rates << " + Kp[" << i << "] * pow(p0/R," << nur << ") * (" << nur
              << ")*(" << nur + 1 << ")/pow(T," << nur + 2 << ") - 2*(" << nur
              << ")/pow(T," << nur + 1 << ") * dTKp[" << i << "]*pow(p0/R,"
              << nur << ")";
      }
      rates << ";" << endl;
    }

    // generating d2Tkr
    rates << endl << "   // Calculate 2nd order derivative of kr" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   d2Tkr[" << i << "] = ( (d2Tkf[" << i << "]*Kc[" << i
            << "]-kf[" << i << "]*d2TKc[" << i << "])*pow(Kc[" << i
            << "],2) - 2*Kc[" << i << "]*dTKc[" << i << "]*(dTkf[" << i
            << "]*Kc[" << i << "] - kf[" << i << "]*dTKc[" << i
            << "]) )/pow(Kc[" << i << "],4);" << endl;
    }

    // set reverse rates of each forward reaction to zero
    rates << endl
          << "   //Set for each forward reaction the reverse rate and their "
             "derivatives to zero"
          << endl;
    for (int i = 0; i < forwardReactions.size(); ++i) {
      rates << "   kr[" << forwardReactions[i] << "] = 0.0;" << endl;
      rates << "   dTkr[" << forwardReactions[i] << "] = 0.0;" << endl;
      rates << "   d2Tkr[" << forwardReactions[i] << "] = 0.0;" << endl;
    }

    // close function and file
    rates << endl << "}";
    rates.close();
  } else {
    cerr << "Format unkwown. Please choose either 'python' or 'c++'." << endl;
  }
}

void generateEvalG(vector<string> species, vector<vector<int>> nuprime,
                   vector<vector<int>> nu2prime,
                   vector<vector<double>> consMatrix, vector<double> Ms,
                   vector<int> bodyPos, vector<int> bodyNumber,
                   vector<vector<double>> bodyCoeff, string filename) {

  // set collocation schema
  double A[NSTAGES][NSTAGES] = ACOLL;

  // get problem dimensions
  int nop = NOP;
  int nnop = NNOP;
  int Iop[NOP] = IOP;
  int Inop[NNOP] = INOP;
  int nspec = species.size();
  int nreac = nuprime[0].size();
  int natom = consMatrix.size();
  int offset = 0;

  int nu[nspec][nreac];
  for (int i = 0; i < nspec; ++i) {
    for (int k = 0; k < nreac; ++k) {
      nu[i][k] = nu2prime[i][k] - nuprime[i][k];
    }
  }

  // get time for time stamp
  time_t t;
  time(&t);

  ofstream evalg("eval_g.hpp");
  evalg << setprecision(15);
  evalg << "/* Autogenerated file on " << ctime(&t);
  evalg << " *    Function defining the contraints of collocation, mass and "
           "enthalpy conservation"
        << endl;
  evalg << " *    Mechanism: " << filename << endl;
  evalg << " */" << endl;
  evalg << "bool ammsockNLP::eval_g(Index n, const Number* x, bool new_x, "
           "Index m, Number* g) {"
        << endl
        << endl;

  // rename variables
  evalg << endl << "   //set variables " << endl;
  evalg << "   Number Y_0_0[" << nop << "] = { x[0]";
  for (int i = 1; i < nop; ++i) {
    evalg << ",  x[" << i << "]";
  }
  evalg << "}, T_0_0 = x[" << nop << "];" << endl;

  for (int k = 0; k <= NINT; ++k) {
    for (int s = 1; s <= NSTAGES; ++s) {
      evalg << "   Number Y_" << k << "_" << s << "[" << nop << "] = { x["
            << nop + k * NSTAGES * (nop + 1) + (s - 1) * (nop + 1) + 1 << "]";
      for (int i = 1; i < nop; ++i) {
        evalg << ", x["
              << nop + k * NSTAGES * (nop + 1) + (s - 1) * (nop + 1) + i + 1
              << "]";
      }
      evalg << "}, T_" << k << "_" << s << " = x["
            << nop + k * NSTAGES * (nop + 1) + (s - 1) * (nop + 1) + nop + 1
            << "];" << endl;
    }
  }
  evalg << endl;

  evalg << "   // Preliminaries: set molar weights, get f and H - coding "
           "NAME_INTERVAL_STAGE"
        << endl;
  evalg << "   Number Ms[" << nspec << "] = { " << 1e-3 * Ms[0];
  for (int i = 1; i < Ms.size(); ++i) {
    evalg << ", " << 1e-3 * Ms[i];
  }
  evalg << "}; //molar weights in kg/mol" << endl;

  evalg << "   Number f_0_0[" << nop << "],";
  for (int k = 0; k < NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << " f_" << k << "_" << i << "[" << nop << "],";
    }
  }
  for (int i = 1; i < NSTAGES; ++i) {
    evalg << " f_" << NINT << "_" << i << "[" << nop << "],";
  }
  evalg << " f_" << NINT << "_" << NSTAGES << "[" << nop << "];" << endl;
  evalg << "   Number H_0_0[" << nspec << "],";
  for (int k = 0; k < NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << " H_" << k << "_" << i << "[" << nspec << "],";
    }
  }
  for (int i = 1; i < NSTAGES; ++i) {
    evalg << " H_" << NINT << "_" << i << "[" << nspec << "],";
  }
  evalg << " H_" << NINT << "_" << NSTAGES << "[" << nspec << "];" << endl;
  evalg << "   Number Yres_0_0[" << nnop << "],";
  for (int k = 0; k < NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << " Yres_" << k << "_" << i << "[" << nnop << "],";
    }
  }
  for (int i = 1; i < NSTAGES; ++i) {
    evalg << " Yres_" << NINT << "_" << i << "[" << nnop << "],";
  }
  evalg << " Yres_" << NINT << "_" << NSTAGES << "[" << nnop << "];" << endl;
  evalg << endl;

  evalg << "   get_f(T_0_0, Y_0_0, f_0_0, H_0_0, Yres_0_0);" << endl;
  for (int k = 0; k <= NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << "   get_f(T_" << k << "_" << i << ", Y_" << k << "_" << i
            << ", f_" << k << "_" << i << ", H_" << k << "_" << i << ", Yres_"
            << k << "_" << i << ");" << endl;
    }
  }
  evalg << endl;

  // generating constraint function g
  evalg << "   //generating constraint function g" << endl;
  evalg << std::setprecision(15);
  // generate stages approximations
  for (int i = 1; i <= NSTAGES; ++i) {
    for (int s = 0; s < nop; ++s) {
      evalg << "   g[" << (i - 1) * nop + s << "] = Y_0_" << i << "[" << s
            << "] - Y_0_0[" << s << "] - h* ( 0.0";
      for (int j = 1; j <= NSTAGES; ++j) {
        evalg << " + (" << A[i - 1][j - 1] << ") * f_0_" << j << "[" << s
              << "]";
      }
      evalg << ");" << endl;
    }
  }

  // generate enthalpy conservation for each stage
  evalg << "   g[" << NSTAGES * nop << "] = -hFixed";
  for (int s = 0; s < nop; ++s) {
    evalg << " + H_0_0[" << Iop[s] - 1 << "] * Y_0_0[" << s << "]/Ms["
          << Iop[s] - 1 << "]";
  }
  for (int s = 0; s < nnop; ++s) {
    evalg << " + H_0_0[" << Inop[s] - 1 << "] * Yres_0_0[" << s << "]/Ms["
          << Inop[s] - 1 << "]";
  }
  evalg << ";" << endl;
  for (int i = 1; i <= NSTAGES; ++i) {
    evalg << "   g[" << NSTAGES * nop + i << "] = -hFixed";
    for (int s = 0; s < nop; ++s) {
      evalg << " + H_0_" << i << "[" << Iop[s] - 1 << "] * Y_0_" << i << "["
            << s << "]/Ms[" << Iop[s] - 1 << "]";
    }
    for (int s = 0; s < nnop; ++s) {
      evalg << " + H_0_" << i << "[" << Inop[s] - 1 << "] * Yres_0_" << i << "["
            << s << "]/Ms[" << Inop[s] - 1 << "]";
    }
    evalg << ";" << endl;
  }

  // generate collocations schema for each intervall
  offset = NSTAGES * (nop + 1) + 1;
  for (int k = 1; k <= NINT; ++k) {
    // generate stages approximations
    for (int i = 1; i <= NSTAGES; ++i) {
      for (int s = 0; s < nop; ++s) {
        evalg << "   g["
              << offset + (k - 1) * NSTAGES * (nop + 1) + (i - 1) * nop + s
              << "] = Y_" << k << "_" << i << "[" << s << "] - Y_" << k - 1
              << "_" << NSTAGES << "[" << s << "] - h* ( 0.0";
        for (int j = 1; j <= NSTAGES; ++j) {
          evalg << " + (" << A[i - 1][j - 1] << ") * f_" << k << "_" << j << "["
                << s << "]";
        }
        evalg << ");" << endl;
      }
    }

    // generate enthalpy conservation for each stage
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << "   g["
            << offset + (k - 1) * NSTAGES * (nop + 1) + NSTAGES * nop + i - 1
            << "] = -hFixed";
      for (int s = 0; s < nop; ++s) {
        evalg << " + H_" << k << "_" << i << "[" << Iop[s] - 1 << "] * Y_" << k
              << "_" << i << "[" << s << "]/Ms[" << Iop[s] - 1 << "]";
      }
      for (int s = 0; s < nnop; ++s) {
        evalg << " + H_" << k << "_" << i << "[" << Inop[s] - 1 << "] * Yres_"
              << k << "_" << i << "[" << s << "]/Ms[" << Inop[s] - 1 << "]";
      }
      evalg << ";" << endl;
    }
  }

  // generate mass conservation for y(t_f) if there is no NNOP
  offset = offset + (NINT - 1) * NSTAGES * (nop + 1) + NSTAGES * nop + NSTAGES;
  if (NNOP == 0) {
    for (int a = 0; a < natom; ++a) {
      evalg << "   g[" << offset + a << "] = -consAtom[" << a << "]";
      for (int s = 0; s < nop; ++s) {
        if (consMatrix[a][s] != 0) {
          evalg << setprecision(15) << " + " << consMatrix[a][s] << " * Y_"
                << NINT << "_" << NSTAGES << "[" << s << "]";
        }
      }
      evalg << ";" << endl;
    }
    offset += natom;
  }

  // generate fixation of reaction progress variables
  for (int i = 0; i < NRPV; ++i) {
    evalg << "   g[" << offset + i << "] = -rpv_fixed[" << i << "] + Y_" << NINT
          << "_" << NSTAGES << "[rpv_index[" << i << "]];" << endl;
  }
  offset += NRPV;

  // generate nontrivial inequalities
  for (int s = 0; s <= NSTAGES; ++s) {
    for (int i = 0; i < NNOP; ++i) {
      evalg << "   g[" << offset << "] = Yres_0_" << s << "[" << i << "];"
            << endl;
      offset++;
    }
  }
  for (int k = 1; k <= NINT; ++k) {
    for (int s = 1; s <= NSTAGES; ++s) {
      for (int i = 0; i < NNOP; ++i) {
        evalg << "   g[" << offset << "] = Yres_" << k << "_" << s << "[" << i
              << "];" << endl;
        offset++;
      }
    }
  }

  // close function and file
  evalg << endl << "   return true;" << endl;
  evalg << endl << "}";
  evalg.close();
}

void generateEvalJacG(vector<string> species, vector<vector<int>> nuprime,
                      vector<vector<int>> nu2prime,
                      vector<vector<double>> consMatrix, vector<double> Ms,
                      vector<int> bodyPos, vector<int> bodyNumber,
                      vector<vector<double>> bodyCoeff, string filename) {

  // set collocation schema
  double A[NSTAGES][NSTAGES] = ACOLL;

  // get problem dimensions
  int nspec = species.size();
  int nreac = nuprime[0].size();
  int natom = consMatrix.size();
  int nop = NOP;
  int nnop = NNOP;
  int Iop[NOP] = IOP;
  int Inop[NNOP] = INOP;

  int nu[nspec][nreac];
  for (int i = 0; i < nspec; ++i) {
    for (int k = 0; k < nreac; ++k) {
      nu[i][k] = nu2prime[i][k] - nuprime[i][k];
    }
  }

  // get time for time stamp
  time_t t;
  time(&t);

  ofstream evalg("eval_jac_g.hpp");
  evalg << setprecision(15);
  evalg << "/* Autogenerated file on " << ctime(&t);
  evalg << " *    Function defining the structure as well as the values of the "
           "Jacobian of the contraints"
        << endl;
  evalg << " *    Mechanism: " << filename << endl;
  evalg << " */" << endl;
  evalg
      << "bool ammsockNLP::eval_jac_g(Index n, const Number* x, bool new_x, "
         "Index m, Index nele_jac, Index* iRow, Index *jCol, Number* values) {"
      << endl
      << endl;
  evalg << "   // returns structure of jacobian" << endl;
  evalg << "   if (values == NULL) {" << endl;
  int nnzJacG = 0;
  int offset = 0;
  evalg << "      //set index for first intervall: stage approximations"
        << endl;
  for (int s = 1; s <= NSTAGES; ++s) {
    for (int i = 1; i <= nop; ++i) {
      evalg << "      iRow[" << nnzJacG << "] = " << (s - 1) * nop + i
            << "; jCol[" << nnzJacG << "] = " << i << ";" << endl;
      nnzJacG++;
      for (int k = 1; k <= NSTAGES * (nop + 1); ++k) {
        evalg << "      iRow[" << nnzJacG << "] = " << (s - 1) * nop + i
              << "; jCol[" << nnzJacG << "] = " << nop + 1 + k << ";" << endl;
        nnzJacG++;
      }
    }
  }
  evalg << "      //set index for first intervall: enthalpy conservations"
        << endl;
  for (int i = 1; i <= NSTAGES + 1; ++i) {
    for (int s = 1; s <= nop + 1; ++s) {
      evalg << "      iRow[" << nnzJacG << "] = " << NSTAGES * nop + i
            << "; jCol[" << nnzJacG << "] = " << (i - 1) * (nop + 1) + s << ";"
            << endl;
      nnzJacG++;
    }
  }

  for (int k = 1; k <= NINT; ++k) {
    evalg << "      //set index for intervall " << k + 1
          << ": stage approximations" << endl;
    for (int s = 1; s <= NSTAGES; ++s) {
      for (int i = 1; i <= nop; ++i) {
        evalg << "      iRow[" << nnzJacG
              << "] = " << 1 + k * NSTAGES * (nop + 1) + (s - 1) * nop + i
              << "; jCol[" << nnzJacG << "] = "
              << (nop + 1) + (k - 1) * (nop + 1) * NSTAGES +
                     (NSTAGES - 1) * (nop + 1) + i
              << ";" << endl;
        nnzJacG++;
        for (int j = 1; j <= NSTAGES * (nop + 1); ++j) {
          evalg << "      iRow[" << nnzJacG
                << "] = " << 1 + k * NSTAGES * (nop + 1) + (s - 1) * nop + i
                << "; jCol[" << nnzJacG << "] = "
                << (nop + 1) + (k - 1) * (nop + 1) * NSTAGES +
                       NSTAGES * (nop + 1) + j
                << ";" << endl;
          nnzJacG++;
        }
      }
    }

    evalg << "      //set index for intervall " << k + 1
          << ": enthalpy conservations" << endl;
    for (int i = 1; i <= NSTAGES; ++i) {
      for (int s = 1; s <= nop + 1; ++s) {
        evalg << "      iRow[" << nnzJacG
              << "] = " << 1 + k * NSTAGES * (nop + 1) + NSTAGES * nop + i
              << "; jCol[" << nnzJacG << "] = "
              << (nop + 1) + (k - 1) * (nop + 1) * NSTAGES +
                     NSTAGES * (nop + 1) + (i - 1) * (nop + 1) + s
              << ";" << endl;
        nnzJacG++;
      }
    }
  }

  if (NNOP == 0) {
    evalg << "      //set index for mass conservations" << endl;
    for (int a = 1; a <= natom; ++a) {
      for (int s = 1; s <= nop; ++s) {
        //	if (consMatrix[a-1][s-1] != 0) {
        evalg << "      iRow[" << nnzJacG << "] = "
              << 1 + NINT * NSTAGES * (nop + 1) + NSTAGES * nop + NSTAGES + a
              << "; jCol[" << nnzJacG << "] = "
              << (nop + 1) + NINT * (nop + 1) * NSTAGES +
                     (NSTAGES - 1) * (nop + 1) + s
              << ";" << endl;
        nnzJacG++;
        //	}
      }
    }
    offset += natom;
  }

  evalg << "      //set index for fixation of reaction progress variables"
        << endl;
  for (int i = 0; i < NRPV; ++i) {
    evalg << "      iRow[" << nnzJacG << "] = "
          << 1 + NINT * NSTAGES * (nop + 1) + NSTAGES * nop + NSTAGES + offset +
                 i + 1
          << "; jCol[" << nnzJacG << "] = "
          << (nop + 1) + NINT * (nop + 1) * NSTAGES + (NSTAGES - 1) * (nop + 1)
          << "+rpv_index[" << i << "]+1;" << endl;
    nnzJacG++;
  }
  offset = 1 + NINT * NSTAGES * (nop + 1) + NSTAGES * nop + NSTAGES + offset +
           NRPV + 1;
  /*
          evalg << "   //set index for nontrivial inequalities" << endl;
          for (int i = 0; i < nnop; ++i) {
                  for (int s = 0; s < nop; ++s) {
                          evalg << "      iRow["<<nnzJacG<<"] = "<<offset+i<<";
     jCol["<<nnzJacG<<"] = " <<
     (NOP+1)+NINT*NSTAGES*(NOP+1)+(NSTAGES-1)*(NOP+1)+s+1 << ";" << endl;
     nnzJacG++;
                  }
          }
  */

  evalg << "   //set index for nontrivial inequalities" << endl;
  for (int i = 0; i < nnop; ++i) {
    for (int s = 0; s < nop; ++s) {
      evalg << "      iRow[" << nnzJacG << "] = " << offset + i << "; jCol["
            << nnzJacG << "] = " << s + 1 << ";" << endl;
      nnzJacG++;
    }
  }
  offset += nnop;
  for (int k = 0; k <= NINT; ++k) {
    for (int s = 0; s < NSTAGES; ++s) {
      for (int i = 0; i < nnop; ++i) {
        for (int m = 0; m < nop; ++m) {
          evalg << "      iRow[" << nnzJacG << "] = " << offset << "; jCol["
                << nnzJacG << "] = "
                << (NOP + 1) + k * NSTAGES * (NOP + 1) + s * (NOP + 1) + m + 1
                << ";" << endl;
          nnzJacG++;
        }
        offset++;
      }
    }
  }

  evalg << "   // retruns entries in jacobian" << endl;
  evalg << "   } else {" << endl;

  // rename variables
  evalg << endl
        << "   //set variables and molar weights - coding NAME_INTERVAL_STAGE"
        << endl;
  evalg << "   Number Ms[" << nspec << "] = { " << 1e-3 * Ms[0];
  for (int i = 1; i < Ms.size(); ++i) {
    evalg << ", " << 1e-3 * Ms[i];
  }
  evalg << "}; //molar weights in kg/mol" << endl;
  evalg << "   Number Y_0_0[" << nop << "] = { x[0]";
  for (int i = 1; i < nop; ++i) {
    evalg << ",  x[" << i << "]";
  }
  evalg << "}, T_0_0 = x[" << nop << "];" << endl;

  for (int k = 0; k <= NINT; ++k) {
    for (int s = 1; s <= NSTAGES; ++s) {
      evalg << "   Number Y_" << k << "_" << s << "[" << nop << "] = { x["
            << nop + k * NSTAGES * (nop + 1) + (s - 1) * (nop + 1) + 1 << "]";
      for (int i = 1; i < nop; ++i) {
        evalg << ", x["
              << nop + k * NSTAGES * (nop + 1) + (s - 1) * (nop + 1) + i + 1
              << "]";
      }
      evalg << "}, T_" << k << "_" << s << " = x["
            << nop + k * NSTAGES * (nop + 1) + (s - 1) * (nop + 1) + nop + 1
            << "];" << endl;
    }
  }
  evalg << endl;

  // get required derivatives
  evalg << "   // get required derivatives" << endl;
  evalg << "   Number f_0_0[" << nop << "]";
  for (int k = 0; k <= NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << ", f_" << k << "_" << i << "[" << nop << "]";
    }
  }
  evalg << ";" << endl;
  evalg << "   Number H_0_0[" << nspec << "]";
  for (int k = 0; k <= NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << ", H_" << k << "_" << i << "[" << nspec << "]";
    }
  }
  evalg << ";" << endl;
  evalg << "   Number Yres_0_0[" << nnop << "]";
  for (int k = 0; k <= NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << ", Yres_" << k << "_" << i << "[" << nnop << "]";
    }
  }
  evalg << ";" << endl;
  evalg << "   Number dTf_0_0[" << nop << "]";
  for (int k = 0; k <= NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << ", dTf_" << k << "_" << i << "[" << nop << "]";
    }
  }
  evalg << ";" << endl;
  evalg << "   Number dTH_0_0[" << nspec << "]";
  for (int k = 0; k <= NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << ", dTH_" << k << "_" << i << "[" << nspec << "]";
    }
  }
  evalg << ";" << endl;
  evalg << "   Number dYf_0_0[" << nop << "][" << nop << "]";
  for (int k = 0; k <= NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << ", dYf_" << k << "_" << i << "[" << nop << "][" << nop << "]";
    }
  }
  evalg << ";" << endl;
  evalg << "   Number dYYres_0_0[" << nnop << "][" << nop << "]";
  for (int k = 0; k <= NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << ", dYYres_" << k << "_" << i << "[" << nnop << "][" << nop
            << "]";
    }
  }
  evalg << ";" << endl;
  evalg << endl;

  evalg << "   //get first derivatives" << endl;
  evalg << "   getFirstDerivative_f(T_0_0, Y_0_0, f_0_0, dYf_0_0, dTf_0_0, "
           "H_0_0, dTH_0_0, Yres_0_0, dYYres_0_0);"
        << endl;
  for (int k = 0; k <= NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << "   getFirstDerivative_f(T_" << k << "_" << i << ", Y_" << k
            << "_" << i << ", f_" << k << "_" << i << ", dYf_" << k << "_" << i
            << ", dTf_" << k << "_" << i << ", H_" << k << "_" << i << ", dTH_"
            << k << "_" << i << ", Yres_" << k << "_" << i << ", dYYres_" << k
            << "_" << i << ");" << endl;
    }
  }
  evalg << endl;

  // generating constraint Jacobian values
  nnzJacG = 0;
  evalg << setprecision(15);
  for (int i = 1; i <= NSTAGES; ++i) {
    evalg << endl;
    evalg << "   // set derivatives of (interval,stage) = (0," << i << ")"
          << endl;
    for (int s = 0; s < nop; ++s) {
      evalg << "   values[" << nnzJacG << "] = -1.0;" << endl;
      nnzJacG++;
      for (int j = 1; j <= NSTAGES; ++j) {
        for (int m = 0; m < nop; ++m) {
          if ((s == m) && (i == j)) {
            evalg << "   values[" << nnzJacG << "] = 1.0-h*(" << A[i - 1][j - 1]
                  << ")*dYf_0_" << j << "[" << s << "][" << m << "];" << endl;
            nnzJacG++;
          } else {
            evalg << "   values[" << nnzJacG << "] = -h*(" << A[i - 1][j - 1]
                  << ")*dYf_0_" << j << "[" << s << "][" << m << "];" << endl;
            nnzJacG++;
          }
        }
        evalg << "   values[" << nnzJacG << "] = -h*(" << A[i - 1][j - 1]
              << ")*dTf_0_" << j << "[" << s << "];" << endl;
        nnzJacG++;
      }
    }
  }
  evalg << endl;

  // set derivatives of enthalply conservation for each stages
  evalg << "   // set derivatives of enthalpy conservation" << endl;
  for (int s = 0; s < nop; ++s) {
    evalg << "   values[" << nnzJacG << "] = H_0_0[" << Iop[s] - 1 << "]/Ms["
          << Iop[s] - 1 << "]";
    for (int m = 0; m < nnop; ++m) {
      evalg << " + H_0_0[" << Inop[m] - 1 << "]/Ms[" << Inop[m] - 1
            << "] * dYYres_0_0[" << m << "][" << s << "]";
    }
    evalg << ";" << endl;
    nnzJacG++;
  }
  evalg << "   values[" << nnzJacG << "] = 0.0";
  for (int s = 0; s < nop; ++s) {
    evalg << " + dTH_0_0[" << Iop[s] - 1 << "] * Y_0_0[" << s << "]/Ms["
          << Iop[s] - 1 << "]";
  }
  for (int s = 0; s < nnop; ++s) {
    evalg << " + dTH_0_0[" << Inop[s] - 1 << "] * Yres_0_0[" << s << "]/Ms["
          << Inop[s] - 1 << "]";
  }
  evalg << ";" << endl;
  nnzJacG++;

  for (int i = 1; i <= NSTAGES; ++i) {
    evalg << endl;
    for (int s = 0; s < nop; ++s) {
      evalg << "   values[" << nnzJacG << "] = H_0_" << i << "[" << Iop[s] - 1
            << "]/Ms[" << Iop[s] - 1 << "]";
      for (int m = 0; m < nnop; ++m) {
        evalg << " + H_0_" << i << "[" << Inop[m] - 1 << "]/Ms[" << Inop[m] - 1
              << "] * dYYres_0_" << i << "[" << m << "][" << s << "]";
      }
      evalg << ";" << endl;
      nnzJacG++;
    }
    evalg << "   values[" << nnzJacG << "] = 0.0";
    for (int s = 0; s < nop; ++s) {
      evalg << " + dTH_0_" << i << "[" << Iop[s] - 1 << "] * Y_0_" << i << "["
            << s << "]/Ms[" << Iop[s] - 1 << "]";
    }
    for (int s = 0; s < nnop; ++s) {
      evalg << " + dTH_0_" << i << "[" << Inop[s] - 1 << "] * Yres_0_" << i
            << "[" << s << "]/Ms[" << Inop[s] - 1 << "]";
    }
    evalg << ";" << endl;
    nnzJacG++;
  }

  for (int k = 1; k <= NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << endl;
      evalg << "   // set derivatives of (interval,stage) = (" << k << "," << i
            << ")" << endl;
      for (int s = 0; s < nop; ++s) {
        evalg << "   values[" << nnzJacG << "] = -1.0;" << endl;
        nnzJacG++;
        for (int j = 1; j <= NSTAGES; ++j) {
          for (int m = 0; m < nop; ++m) {
            if ((s == m) && (i == j)) {
              evalg << "   values[" << nnzJacG << "] = 1.0-h*("
                    << A[i - 1][j - 1] << ")*dYf_" << k << "_" << j << "[" << s
                    << "][" << m << "];" << endl;
              nnzJacG++;
            } else {
              evalg << "   values[" << nnzJacG << "] = -h*(" << A[i - 1][j - 1]
                    << ")*dYf_" << k << "_" << j << "[" << s << "][" << m
                    << "];" << endl;
              nnzJacG++;
            }
          }
          evalg << "   values[" << nnzJacG << "] = -h*(" << A[i - 1][j - 1]
                << ")*dTf_" << k << "_" << j << "[" << s << "];" << endl;
          nnzJacG++;
        }
      }
    }
    evalg << endl;

    // set derivatives of enthalply conservation for each stages
    evalg << "   // set derivatives of enthalpy conservation" << endl;
    for (int i = 1; i <= NSTAGES; ++i) {
      for (int s = 0; s < nop; ++s) {
        evalg << "   values[" << nnzJacG << "] = H_" << k << "_" << i << "["
              << Iop[s] - 1 << "]/Ms[" << Iop[s] - 1 << "]";
        for (int m = 0; m < nnop; ++m) {
          evalg << " + H_" << k << "_" << i << "[" << Inop[m] - 1 << "]/Ms["
                << Inop[m] - 1 << "] * dYYres_" << k << "_" << i << "[" << m
                << "][" << s << "]";
        }
        evalg << ";" << endl;
        nnzJacG++;
      }
      evalg << "   values[" << nnzJacG << "] = 0.0";
      for (int s = 0; s < nop; ++s) {
        evalg << " + dTH_" << k << "_" << i << "[" << Iop[s] - 1 << "] * Y_"
              << k << "_" << i << "[" << s << "]/Ms[" << Iop[s] - 1 << "]";
      }
      for (int s = 0; s < nnop; ++s) {
        evalg << " + dTH_" << k << "_" << i << "[" << Inop[s] - 1 << "] * Yres_"
              << k << "_" << i << "[" << s << "]/Ms[" << Inop[s] - 1 << "]";
      }
      evalg << ";" << endl;
      nnzJacG++;
    }
  }

  // if there is no resolution
  if (NNOP == 0) {
    evalg << "   // set derivatives of mass conservation" << endl;
    for (int a = 1; a <= natom; ++a) {
      for (int s = 1; s <= nspec; ++s) {
        evalg << "   values[" << nnzJacG << "] = " << std::setprecision(15)
              << consMatrix[a - 1][s - 1] << ";" << endl;
        nnzJacG++;
      }
    }
  }

  // set derivatvie of the fixiation of the rpv
  for (int i = 0; i < NRPV; ++i) {
    evalg << "   values[" << nnzJacG << "] = 1.0;" << endl;
    nnzJacG++;
  }

  // set nontrivial inequalities
  if (NNOP > 0) {
    evalg << "   //set inequalities. Note: dYYres = const. so we only use "
             "dYYres_0_0"
          << endl;
    for (int k = 0; k < (NSTAGES * (NINT + 1) + 1); ++k) {
      for (int m = 0; m < nnop; ++m) {
        for (int i = 0; i < nop; ++i) {
          evalg << "   values[" << nnzJacG << "] = dYYres_0_0[" << m << "]["
                << i << "];" << endl;
          nnzJacG++;
        }
      }
    }
  }

  // close function and file
  evalg << "   }" << endl;
  evalg << endl << "   return true;" << endl;
  evalg << endl << "}";

  evalg.close();
}

void generateAuxiliary(vector<string> species, vector<vector<int>> nuprime,
                       vector<vector<int>> nu2prime,
                       vector<vector<double>> consMatrix, vector<double> Ms,
                       vector<int> bodyPos, vector<int> bodyNumber,
                       vector<vector<double>> bodyCoeff, string filename) {

  // get problem dimensions
  int nop = NOP;
  int nnop = NNOP;
  int ntb = NTB;
  int Iop[NOP] = IOP;
  int Inop[NNOP] = INOP;
  int nspec = species.size();
  int nreac = nuprime[0].size();

  int nu[nspec][nreac];
  for (int i = 0; i < nspec; ++i) {
    for (int k = 0; k < nreac; ++k) {
      nu[i][k] = nu2prime[i][k] - nuprime[i][k];
    }
  }

  // get time for time stamp
  time_t t;
  time(&t);

  ofstream evalg("auxiliaries.hpp");
  evalg << "/* Autogenerated file on " << ctime(&t);
  evalg << " *    Function defining some useful auxilary functions" << endl;
  evalg << " *    Mechanism: " << filename << endl;
  evalg << " */" << endl << endl;

  evalg << "void ammsockNLP::get_f(const Number T, const Number Y[" << nop
        << "], Number f[" << nop << "]) {" << endl
        << endl;
  // prepare preliminares
  evalg << "   //allocate memory" << endl;
  evalg << "   Number rho, Mbar;" << endl;
  evalg << "   Number q[" << nreac << "], qtilde[" << nreac << "];" << endl;
  evalg << "   Number omega[" << nop << "];" << endl;
  evalg << "   Number M[" << bodyCoeff.size() << "];" << endl;
  evalg << "   Number Gp[" << nreac << "], Gm[" << nreac << "];" << endl;
  evalg << "   Number Rp[" << nreac << "], Rm[" << nreac << "];" << endl;
  evalg << "   Number kf[" << nreac << "], dTkf[" << nreac << "], dTTkf["
        << nreac << "];" << endl;
  evalg << "   Number kr[" << nreac << "], dTkr[" << nreac << "], dTTkr["
        << nreac << "];" << endl;
  evalg << "   Number H[" << nspec << "], dTH[" << nspec << "], dTTH[" << nspec
        << "];" << endl;
  evalg << endl;
  evalg << "   //call overloaded function" << endl;
  evalg << "   "
           "get_f(T,Y,f,rho,Mbar,q,qtilde,omega,M,Gp,Gm,Rp,Rm,kf,dTkf,dTTkf,kr,"
           "dTkr,dTTkr,H,dTH,dTTH);"
        << endl;

  evalg << endl;
  evalg << "}" << endl;

  evalg << endl;

  evalg << "void ammsockNLP::get_f(const Number T, const Number _Y[" << nop
        << "], Number f[" << nop << "], Number H[" << nspec << "], Number Yres["
        << nnop << "]) {" << endl
        << endl;

  // prepare preliminares
  evalg << "   //allocate memory" << endl;
  evalg << "   Number rho, Mbar;" << endl;
  evalg << "   Number q[" << nreac << "], qtilde[" << nreac << "];" << endl;
  evalg << "   Number omega[" << nop << "];" << endl;
  evalg << "   Number M[" << bodyCoeff.size() << "];" << endl;
  evalg << "   Number Gp[" << nreac << "], Gm[" << nreac << "];" << endl;
  evalg << "   Number Rp[" << nreac << "], Rm[" << nreac << "];" << endl;
  evalg << "   Number kf[" << nreac << "], dTkf[" << nreac << "], dTTkf["
        << nreac << "];" << endl;
  evalg << "   Number kr[" << nreac << "], dTkr[" << nreac << "], dTTkr["
        << nreac << "];" << endl;
  evalg << "   Number dTH[" << nspec << "], dTTH[" << nspec << "];" << endl;
  evalg << endl;
  evalg << "   //set resolved species" << endl;
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Yres[" << i << "] = Y" << Inop[i] - 1 << "RES;" << endl;
  }
  evalg << endl;
  evalg << "   //call overloaded function" << endl;
  evalg << "   "
           "get_f(T,_Y,f,rho,Mbar,q,qtilde,omega,M,Gp,Gm,Rp,Rm,kf,dTkf,dTTkf,"
           "kr,dTkr,dTTkr,H,dTH,dTTH);"
        << endl;

  evalg << endl;
  evalg << "}" << endl;

  evalg << endl;

  evalg << "void ammsockNLP::get_f(const Number T, const Number _Y[" << nop
        << "], Number f[" << nop << "], Number &rho, Number &Mbar, Number q["
        << nreac << "], Number qtilde[" << nreac << "], Number omega[" << nop
        << "], Number M[" << ntb << "],  Number Gp[" << nreac << "], Number Gm["
        << nreac << "],Number Rp[" << nreac << "], Number Rm[" << nreac
        << "], Number kf[" << nreac << "], Number dTkf[" << nreac
        << "], Number dTTkf[" << nreac << "], Number kr[" << nreac
        << "], Number dTkr[" << nreac << "], Number dTTkr[" << nreac
        << "], Number H[" << nspec << "], Number dTH[" << nspec
        << "], Number dTTH[" << nspec << "]) {" << endl
        << endl;

  // prepare preliminares
  evalg << "   // Preliminaries" << endl;
  evalg << "   Number Y[" << nspec << "];" << endl;
  for (int i = 0; i < nop; ++i) {
    evalg << "   Y[" << Iop[i] - 1 << "] = _Y[" << i << "];" << endl;
  }
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Y[" << Inop[i] - 1 << "] = Y" << Inop[i] - 1 << "RES;" << endl;
  }
  evalg << "   Number Ms[" << nspec << "] = { " << std::setprecision(15)
        << 1e-3 * Ms[0];
  for (int i = 1; i < Ms.size(); ++i) {
    evalg << ", " << 1e-3 * Ms[i];
  }
  evalg << "}; //molar weights in kg/mol" << endl;
  evalg << "   Number p = 101325; // fixed pressure in an isobaric case"
        << endl;
  evalg << "   Number R = 8.3144598;" << endl << endl;

  evalg << "   //calculate Mbar and density rho" << endl;
  evalg << "   Mbar = 1.0/( 0.0";
  for (int i = 0; i < nspec; ++i) {
    evalg << " + Y[" << i << "]/Ms[" << i << "] ";
  }
  evalg << ");" << endl;
  evalg << "   rho = p*Mbar/(R*T);" << endl;

  // calculate rates
  evalg << endl << "   // Calculate rates" << endl;
  evalg << "   rates(T,kf,kr,dTkf,dTkr,dTTkf,dTTkr,H,dTH,dTTH);" << endl;

  // generating third bodies
  evalg << endl << "   // Generate third bodies" << endl;
  for (int i = 0; i < bodyCoeff.size(); ++i) {
    evalg << "   M[" << i << "] = 0.0";
    for (int k = 0; k < nspec; ++k) {
      evalg << " + " << bodyCoeff[i][k] << " * rho*Y[" << k << "]/Ms[" << k
            << "]";
    }
    evalg << ";" << endl;
  }
  evalg << endl;

  evalg << "   // general terms and rest terms" << endl;
  for (int r = 0; r < nreac; ++r) {
    evalg << "   Gp[" << r << "] = 1.0";
    for (int k = 0; k < nop; ++k) {
      if (nuprime[Iop[k] - 1][r] != 0) {
        for (int i = 1; i <= nuprime[Iop[k] - 1][r]; ++i) {
          evalg << "* Y[" << Iop[k] - 1 << "]/Ms[" << Iop[k] - 1 << "]";
        }
      }
    }
    evalg << ";" << endl;
  }
  for (int r = 0; r < nreac; ++r) {
    evalg << "   Gm[" << r << "] = 1.0";
    for (int k = 0; k < nop; ++k) {
      if (nu2prime[Iop[k] - 1][r] != 0) {
        for (int i = 1; i <= nu2prime[Iop[k] - 1][r]; ++i) {
          evalg << "* Y[" << Iop[k] - 1 << "]/Ms[" << Iop[k] - 1 << "]";
        }
      }
    }
    evalg << ";" << endl;
  }
  for (int r = 0; r < nreac; ++r) {
    evalg << "   Rp[" << r << "] = 1.0";
    for (int k = 0; k < nnop; ++k) {
      if (nuprime[Inop[k] - 1][r] != 0) {
        for (int i = 1; i <= nuprime[Inop[k] - 1][r]; ++i) {
          evalg << "* Y[" << Inop[k] - 1 << "]/Ms[" << Inop[k] - 1 << "]";
        }
      }
    }
    evalg << ";" << endl;
  }
  for (int r = 0; r < nreac; ++r) {
    evalg << "   Rm[" << r << "] = 1.0";
    for (int k = 0; k < nnop; ++k) {
      if (nu2prime[Inop[k] - 1][r] != 0) {
        for (int i = 1; i <= nu2prime[Inop[k] - 1][r]; ++i) {
          evalg << "* Y[" << Inop[k] - 1 << "]/Ms[" << Inop[k] - 1 << "]";
        }
      }
    }
    evalg << ";" << endl;
  }
  evalg << endl;

  // generate qtilde
  evalg << "   // Generate qtilde for each reaction" << endl;
  for (int i = 0; i < nreac; ++i) {
    // get nubarprime, nubar2prime
    int nubarprime = 0;
    int nubar2prime = 0;
    for (int s = 0; s < nspec; ++s) {
      nubarprime += nuprime[s][i];
      nubar2prime += nu2prime[s][i];
    }
    evalg << "   qtilde[" << i << "] = "
          << "kf[" << i << "] * pow(rho," << nubarprime << ") * Gp[" << i
          << "] * Rp[" << i << "] - kr[" << i << "] * pow(rho," << nubar2prime
          << ") * Gm[" << i << "] * Rm[" << i << "];" << endl;
  }
  evalg << endl;

  // generate q
  evalg << "   // Generate q" << endl;
  for (int i = 0; i < nreac; ++i) {
    int ind = thirdBodyOccurs(bodyPos, i);
    // if there isn't a third body
    if (ind == -1) {
      evalg << "   q[" << i << "] = qtilde[" << i << "];" << endl;
      // otherwise use product rule
    } else {
      int whichThirdBody = bodyNumber[ind] - 1;
      evalg << "   q[" << i << "] = M[" << whichThirdBody << "] * qtilde[" << i
            << "];" << endl;
    }
  }
  evalg << endl;

  // generating omega
  evalg << "   // Generate omega" << endl;
  for (int s = 0; s < nop; ++s) {
    evalg << "   omega[" << s << "] = 0.0 ";
    for (int r = 0; r < nreac; ++r) {
      if (nu[Iop[s] - 1][r] != 0)
        evalg << "+ (" << nu[Iop[s] - 1][r] << ") * "
              << "q[" << r << "] ";
    }
    evalg << ";" << endl;
  }
  evalg << endl;

  // generating dotY
  evalg << "   // Generate f" << endl;
  for (int s = 0; s < nop; ++s) {
    evalg << "   f[" << s << "] = Ms[" << Iop[s] - 1 << "]/rho * omega[" << s
          << "];" << endl;
  }
  evalg << "}" << endl << endl;

  evalg
      << "void ammsockNLP::getFirstDerivative_f(const Number T, const Number Y["
      << nop << "], Number f[" << nop << "], Number dYf[" << nop << "][" << nop
      << "], Number dTf[" << nop << "], Number H[" << nspec << "], Number dTH["
      << nspec << "]) {" << endl
      << endl;
  evalg << "   // Preliminaries" << endl;
  evalg << "   //allocate memory" << endl;
  evalg << "   Number rho, dYrho[" << nop << "], dTrho, Mbar, dYMbar[" << nop
        << "];" << endl;
  evalg << "   Number q[" << nreac << "], dYq[" << nreac << "][" << nop
        << "], dTq[" << nreac << "];" << endl;
  evalg << "   Number qtilde[" << nreac << "], dYqtilde[" << nreac << "]["
        << nop << "], dTqtilde[" << nreac << "];" << endl;
  evalg << "   Number omega[" << nop << "], dYomega[" << nop << "][" << nop
        << "], dTomega[" << nop << "];" << endl;
  evalg << "   Number M[" << ntb << "], dYM[" << ntb << "][" << nop << "], dTM["
        << ntb << "];" << endl;
  evalg << "   Number Gp[" << nreac << "], dYGp[" << nreac << "][" << nop
        << "];" << endl;
  evalg << "   Number Gm[" << nreac << "], dYGm[" << nreac << "][" << nop
        << "];" << endl;
  evalg << "   Number Rp[" << nreac << "], dYRp[" << nreac << "][" << nop
        << "];" << endl;
  evalg << "   Number Rm[" << nreac << "], dYRm[" << nreac << "][" << nop
        << "];" << endl;
  evalg << "   Number kf[" << nreac << "], dTkf[" << nreac << "], dTTkf["
        << nreac << "];" << endl;
  evalg << "   Number kr[" << nreac << "], dTkr[" << nreac << "], dTTkr["
        << nreac << "];" << endl;
  evalg << "   Number dTTH[" << nreac << "];" << endl;

  evalg << endl;

  evalg << "   //call overloaded function" << endl;
  evalg
      << "   "
         "getFirstDerivative_f(T,Y,f,dYf,dTf,rho,dYrho,dTrho,Mbar,dYMbar,q,dYq,"
         "dTq,qtilde,dYqtilde,dTqtilde,omega,dYomega,dTomega,M,dYM,dTM,Gp,dYGp,"
         "Gm,dYGm,Rp,dYRp,Rm,dYRm,kf,dTkf,dTTkf,kr,dTkr,dTTkr,H,dTH,dTTH);"
      << endl;

  // close function
  evalg << endl << "}" << endl << endl;

  evalg << "void ammsockNLP::getFirstDerivative_f(const Number T, const Number "
           "_Y["
        << nop << "], Number f[" << nop << "], Number dYf[" << nop << "]["
        << nop << "], Number dTf[" << nop << "], Number H[" << nspec
        << "], Number dTH[" << nspec << "], Number Yres[" << nnop
        << "], Number dYYres[" << nnop << "][" << nop << "]) {" << endl
        << endl;
  evalg << "   // Preliminaries" << endl;
  evalg << "   //allocate memory" << endl;
  evalg << "   Number rho, dYrho[" << nop << "], dTrho, Mbar, dYMbar[" << nop
        << "];" << endl;
  evalg << "   Number q[" << nreac << "], dYq[" << nreac << "][" << nop
        << "], dTq[" << nreac << "];" << endl;
  evalg << "   Number qtilde[" << nreac << "], dYqtilde[" << nreac << "]["
        << nop << "], dTqtilde[" << nreac << "];" << endl;
  evalg << "   Number omega[" << nop << "], dYomega[" << nop << "][" << nop
        << "], dTomega[" << nop << "];" << endl;
  evalg << "   Number M[" << ntb << "], dYM[" << ntb << "][" << nop << "], dTM["
        << ntb << "];" << endl;
  evalg << "   Number Gp[" << nreac << "], dYGp[" << nreac << "][" << nop
        << "];" << endl;
  evalg << "   Number Gm[" << nreac << "], dYGm[" << nreac << "][" << nop
        << "];" << endl;
  evalg << "   Number Rp[" << nreac << "], dYRp[" << nreac << "][" << nop
        << "];" << endl;
  evalg << "   Number Rm[" << nreac << "], dYRm[" << nreac << "][" << nop
        << "];" << endl;
  evalg << "   Number kf[" << nreac << "], dTkf[" << nreac << "], dTTkf["
        << nreac << "];" << endl;
  evalg << "   Number kr[" << nreac << "], dTkr[" << nreac << "], dTTkr["
        << nreac << "];" << endl;
  evalg << "   Number dTTH[" << nreac << "];" << endl;
  evalg << endl;

  evalg << "   //set resolved species and their derivatives" << endl;
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Yres[" << i << "] = Y" << Inop[i] - 1 << "RES;" << endl;
  }
  evalg << "   //define derivatives of resolutions" << endl;
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Number dYY" << i << "[" << nop << "] =  DIFFY" << Inop[i] - 1
          << "RES;" << endl;
  }
  for (int i = 0; i < nnop; ++i) {
    for (int j = 0; j < nop; ++j) {
      evalg << "   dYYres[" << i << "][" << j << "] = dYY" << i << "[" << j
            << "];" << endl;
    }
  }
  evalg << endl;

  evalg << "   //call overloaded function" << endl;
  evalg
      << "   "
         "getFirstDerivative_f(T,_Y,f,dYf,dTf,rho,dYrho,dTrho,Mbar,dYMbar,q,"
         "dYq,dTq,qtilde,dYqtilde,dTqtilde,omega,dYomega,dTomega,M,dYM,dTM,Gp,"
         "dYGp,Gm,dYGm,Rp,dYRp,Rm,dYRm,kf,dTkf,dTTkf,kr,dTkr,dTTkr,H,dTH,dTTH);"
      << endl;

  // close function
  evalg << endl << "}" << endl << endl;

  evalg << "void ammsockNLP::getFirstDerivative_f(const Number T, const Number "
           "_Y["
        << nop << "]," << endl;
  evalg << "					Number f[" << nop
        << "], Number dYf[" << nop << "][" << nop << "], Number dTf[" << nop
        << "]," << endl;
  evalg << "					Number &rho, Number dYrho["
        << nop << "], Number &dTrho," << endl;
  evalg << "					Number &Mbar, Number dYMbar["
        << nop << "]," << endl;
  evalg << "					Number q[" << nreac
        << "], Number dYq[" << nreac << "][" << nop << "], Number dTq[" << nreac
        << "]," << endl;
  evalg << "					Number qtilde[" << nreac
        << "], Number dYqtilde[" << nreac << "][" << nop
        << "], Number dTqtilde[" << nreac << "]," << endl;
  evalg << "					Number omega[" << nop
        << "], Number dYomega[" << nop << "][" << nop << "], Number dTomega["
        << nop << "]," << endl;
  evalg << "					Number M[" << ntb
        << "], Number dYM[" << ntb << "][" << nop << "], Number dTM[" << ntb
        << "]," << endl;
  evalg << "					Number Gp[" << nreac
        << "], Number dYGp[" << nreac << "][" << nop << "]," << endl;
  evalg << "					Number Gm[" << nreac
        << "], Number dYGm[" << nreac << "][" << nop << "]," << endl;
  evalg << "					Number Rp[" << nreac
        << "], Number dYRp[" << nreac << "][" << nop << "]," << endl;
  evalg << "					Number Rm[" << nreac
        << "], Number dYRm[" << nreac << "][" << nop << "]," << endl;
  evalg << "					Number kf[" << nreac
        << "], Number dTkf[" << nreac << "], Number dTTkf[" << nreac << "],"
        << endl;
  evalg << "					Number kr[" << nreac
        << "], Number dTkr[" << nreac << "], Number dTTkr[" << nreac << "],"
        << endl;
  evalg << "					Number H[" << nspec
        << "], Number dTH[" << nspec << "], Number dTTH[" << nspec << "]) {"
        << endl
        << endl;
  evalg << "   // Preliminaries" << endl;
  evalg << "   Number Y[" << nspec << "];" << endl;
  for (int i = 0; i < nop; ++i) {
    evalg << "   Y[" << Iop[i] - 1 << "] = _Y[" << i << "];" << endl;
  }
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Y[" << Inop[i] - 1 << "] = Y" << Inop[i] - 1 << "RES;" << endl;
  }

  evalg << "   Number Ms[" << nspec << "] = { " << std::setprecision(15)
        << 1e-3 * Ms[0];
  for (int i = 1; i < Ms.size(); ++i) {
    evalg << ", " << 1e-3 * Ms[i];
  }
  evalg << "}; //molar weights in kg/mol" << endl;

  evalg << "   //define derivatives of resolutions" << endl;
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Number dYY" << Inop[i] - 1 << "[" << nop << "] =  DIFFY"
          << Inop[i] - 1 << "RES;" << endl;
  }

  evalg << "   //call function get_f" << endl;
  evalg << "   "
           "get_f(T,_Y,f,rho,Mbar,q,qtilde,omega,M,Gp,Gm,Rp,Rm,kf,dTkf,dTTkf,"
           "kr,dTkr,dTTkr,H,dTH,dTTH);"
        << endl;

  evalg << "   // density" << endl;
  evalg << "   dTrho = -rho/T;" << endl;
  evalg << "   // Generate dYrho" << endl;
  for (int s = 0; s < nop; ++s) {
    evalg << "   dYrho[" << s << "] = -Mbar*rho*(1/Ms[" << Iop[s] - 1 << "] ";
    for (int i = 0; i < nnop; ++i) {
      evalg << " + 1/Ms[" << Inop[i] - 1 << "] * dYY" << Inop[i] - 1 << "[" << s
            << "]";
    }
    evalg << ");" << endl;
  }
  evalg << endl;

  evalg << "   // Generate dYMbar" << endl;
  for (int s = 0; s < nop; ++s) {
    evalg << "   dYMbar[" << s << "] = -Mbar*Mbar*(1/Ms[" << Iop[s] - 1 << "] ";
    for (int i = 0; i < nnop; ++i) {
      evalg << " + 1/Ms[" << Inop[i] - 1 << "] * dYY" << Inop[i] - 1 << "[" << s
            << "]";
    }
    evalg << ");" << endl;
  }
  evalg << endl;

  evalg << "   // third body" << endl;
  evalg << "   Number sumAlphaYM = 0.0;	" << endl;

  // generating third bodies and their derivatives
  for (int k = 0; k < bodyCoeff.size(); ++k) {
    evalg << "   //generate third body #" << k + 1 << endl;
    evalg << "   sumAlphaYM = 0.0 ";
    for (int s = 0; s < nspec; ++s) {
      evalg << " + " << bodyCoeff[k][s] << " * Y[" << s << "]/Ms[" << s << "]";
    }
    evalg << ";" << endl;
    evalg << "   // Generate dTM" << endl;
    evalg << "   dTM[" << k << "] = -M[" << k << "]/T;" << endl;
    evalg << "   // Generate dYM" << endl;
    for (int s = 0; s < nop; ++s) {
      evalg << "   dYM[" << k << "][" << s << "] = dYrho[" << s
            << "]*sumAlphaYM + rho*(" << bodyCoeff[k][Iop[s] - 1] << "/Ms["
            << Iop[s] - 1 << "]";
      for (int i = 0; i < nnop; ++i) {
        evalg << " + " << bodyCoeff[k][Inop[i] - 1] << "/Ms[" << Inop[i] - 1
              << "] * dYY" << Inop[i] - 1 << "[" << s << "]";
      }
      evalg << ");" << endl;
    }
    evalg << endl;
  }
  evalg << "   // derivatives of general terms" << endl;
  for (int r = 0; r < nreac; ++r) {
    for (int m = 0; m < nop; ++m) {
      evalg << "   dYGp[" << r << "][" << m << "] = 0.0";
      if (nuprime[Iop[m] - 1][r] != 0) {
        evalg << " + (" << nuprime[Iop[m] - 1][r] << ")/Ms[" << Iop[m] - 1
              << "] * pow(Y[" << Iop[m] - 1 << "]/Ms[" << Iop[m] - 1 << "],"
              << nuprime[Iop[m] - 1][r] - 1 << ")";
        for (int i = 0; i < nop; ++i) {
          if (i != m) {
            for (int l = 1; l <= nuprime[Iop[i] - 1][r]; ++l) {
              evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1 << "]";
            }
          }
        }
      }
      evalg << ";" << endl;
    }
  }
  evalg << endl;
  for (int r = 0; r < nreac; ++r) {
    for (int m = 0; m < nop; ++m) {
      evalg << "   dYGm[" << r << "][" << m << "] = 0.0";
      if (nu2prime[Iop[m] - 1][r] != 0) {
        evalg << " + (" << nu2prime[Iop[m] - 1][r] << ")/Ms[" << Iop[m] - 1
              << "] * pow(Y[" << Iop[m] - 1 << "]/Ms[" << Iop[m] - 1 << "],"
              << nu2prime[Iop[m] - 1][r] - 1 << ")";
        for (int i = 0; i < nop; ++i) {
          if (i != m) {
            for (int l = 1; l <= nu2prime[Iop[i] - 1][r]; ++l) {
              evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1 << "]";
            }
          }
        }
      }
      evalg << ";" << endl;
    }
  }
  evalg << endl;

  evalg << "   // derivatives of rest terms" << endl;
  for (int r = 0; r < nreac; ++r) {
    for (int m = 0; m < nop; ++m) {
      evalg << "   dYRp[" << r << "][" << m << "] = 0.0";
      for (int i = 0; i < nnop; ++i) {
        if (nuprime[Inop[i] - 1][r] != 0) {
          evalg << " + (" << nuprime[Inop[i] - 1][r] << ")/Ms[" << Inop[i] - 1
                << "] * pow(Y[" << Inop[i] - 1 << "]/Ms[" << Inop[i] - 1 << "],"
                << nuprime[Inop[i] - 1][r] - 1 << ") * dYY" << Inop[i] - 1
                << "[" << m << "]";
          for (int j = 0; j < nnop; ++j) {
            if ((nuprime[Inop[j] - 1][r]) && (j != i)) {
              evalg << " * pow(Y[" << Inop[j] - 1 << "]/Ms[" << Inop[j] - 1
                    << "]," << nuprime[Inop[j] - 1][r] << ")";
            }
          }
        }
      }
      evalg << ";" << endl;
    }
  }
  evalg << endl;
  for (int r = 0; r < nreac; ++r) {
    for (int m = 0; m < nop; ++m) {
      evalg << "   dYRm[" << r << "][" << m << "] = 0.0";
      for (int i = 0; i < nnop; ++i) {
        if (nu2prime[Inop[i] - 1][r] != 0) {
          evalg << " + (" << nu2prime[Inop[i] - 1][r] << ")/Ms[" << Inop[i] - 1
                << "] * pow(Y[" << Inop[i] - 1 << "]/Ms[" << Inop[i] - 1 << "],"
                << nu2prime[Inop[i] - 1][r] - 1 << ") * dYY" << Inop[i] - 1
                << "[" << m << "]";
          for (int j = 0; j < nnop; ++j) {
            if ((nu2prime[Inop[j] - 1][r]) && (j != i)) {
              evalg << " * pow(Y[" << Inop[j] - 1 << "]/Ms[" << Inop[j] - 1
                    << "]," << nu2prime[Inop[j] - 1][r] << ")";
            }
          }
        }
      }
      evalg << ";" << endl;
    }
  }
  evalg << endl;

  // generating dTqtilde
  evalg << endl << "   // Generate dTqtilde" << endl;
  for (int i = 0; i < nreac; ++i) {
    // get nubarprime, nubar2prime
    int nubarprime = 0;
    int nubar2prime = 0;
    for (int s = 0; s < nspec; ++s) {
      nubarprime += nuprime[s][i];
      nubar2prime += nu2prime[s][i];
    }
    evalg << "   dTqtilde[" << i << "] = ( dTkf[" << i << "] - kf[" << i
          << "]*(" << nubarprime << ")/T )  * pow(rho," << nubarprime
          << ") * Gp[" << i << "] * Rp[" << i << "] - ( dTkr[" << i << "] - kr["
          << i << "]*(" << nubar2prime << ")/T )  * pow(rho," << nubar2prime
          << ") * Gm[" << i << "] * Rm[" << i << "];" << endl;
  }

  // generating dYqtilde
  evalg << endl << "   // Generate dYqtilde" << endl;
  for (int i = 0; i < nreac; ++i) {
    // get nubarprime, nubar2prime
    int nubarprime = 0;
    int nubar2prime = 0;
    for (int s = 0; s < nspec; ++s) {
      nubarprime += nuprime[s][i];
      nubar2prime += nu2prime[s][i];
    }
    for (int s = 0; s < nop; ++s) {
      evalg << "   dYqtilde[" << i << "][" << s << "] = kf[" << i << "] * ( (("
            << nubarprime << ")*pow(rho," << nubarprime - 1 << ") * dYrho[" << s
            << "] * Gp[" << i << "] + pow(rho," << nubarprime << ") * dYGp["
            << i << "][" << s << "]) * Rp[" << i << "] + pow(rho," << nubarprime
            << ") * Gp[" << i << "] * dYRp[" << i << "][" << s << "])";
      evalg << " - kr[" << i << "] * ( ((" << nubar2prime << ")*pow(rho,"
            << nubar2prime - 1 << ") * dYrho[" << s << "] * Gm[" << i
            << "] + pow(rho," << nubar2prime << ") * dYGm[" << i << "][" << s
            << "]) * Rm[" << i << "] + pow(rho," << nubar2prime << ") * Gm["
            << i << "] * dYRm[" << i << "][" << s << "])";
      evalg << ";" << endl;
    }
    evalg << endl;
  }

  // generating dYq
  evalg << endl << "   // Generate dYq" << endl;
  for (int i = 0; i < nreac; ++i) {
    int ind = thirdBodyOccurs(bodyPos, i);
    // if there isn't a third body
    if (ind == -1) {
      for (int s = 0; s < nop; ++s) {
        evalg << "   dYq[" << i << "][" << s << "] = dYqtilde[" << i << "]["
              << s << "];" << endl;
      }
      // otherwise use product rule
    } else {
      int whichThirdBody = bodyNumber[ind] - 1;
      for (int s = 0; s < nop; ++s) {
        evalg << "   dYq[" << i << "][" << s << "] = M[" << whichThirdBody
              << "] * dYqtilde[" << i << "][" << s << "] + dYM["
              << whichThirdBody << "][" << s << "] * qtilde[" << i << "];"
              << endl;
      }
    }
    evalg << endl;
  }

  // generating dTq
  evalg << endl << "   // Generate dTq" << endl;
  for (int i = 0; i < nreac; ++i) {
    int ind = thirdBodyOccurs(bodyPos, i);
    // if there isn't a third body
    if (ind == -1) {
      evalg << "   dTq[" << i << "] = dTqtilde[" << i << "];" << endl;
      // otherwise insert third body
    } else {
      int whichThirdBody = bodyNumber[ind] - 1;
      evalg << "   dTq[" << i << "] = M[" << whichThirdBody << "] * dTqtilde["
            << i << "] + dTM[" << whichThirdBody << "]* qtilde[" << i << "];"
            << endl;
    }
  }
  evalg << endl << endl;

  // generating dYomega
  evalg << endl << "   // Generate dYomega" << endl;
  for (int s = 0; s < nop; ++s) {
    for (int m = 0; m < nop; ++m) {
      evalg << "   dYomega[" << s << "][" << m << "] = 0.0";
      for (int r = 0; r < nreac; ++r) {
        if (nu[Iop[s] - 1][r] != 0)
          evalg << " + (" << nu[Iop[s] - 1][r] << ") * dYq[" << r << "][" << m
                << "]";
      }
      evalg << ";" << endl;
    }
    evalg << endl;
  }

  // generating dTomega
  evalg << endl << "   // Generate dTomega" << endl;
  for (int s = 0; s < nop; ++s) {
    evalg << "   dTomega[" << s << "] = 0.0";
    for (int r = 0; r < nreac; ++r) {
      if (nu[Iop[s] - 1][r] != 0)
        evalg << " + (" << nu[Iop[s] - 1][r] << ") * dTq[" << r << "]";
    }
    evalg << ";" << endl;
  }
  evalg << endl;

  // generating dYf
  evalg << endl << "   // Generate dYf" << endl;
  for (int s = 0; s < nop; ++s) {
    for (int m = 0; m < nop; ++m) {
      evalg << "   dYf[" << s << "][" << m << "] = Ms[" << Iop[s] - 1
            << "] * (1.0/rho*dYomega[" << s << "][" << m << "] - omega[" << s
            << "]/(rho*rho)*dYrho[" << m << "]);" << endl;
    }
    evalg << endl;
  }

  // generating dTf
  evalg << "   // Generate dTf" << endl;
  for (int s = 0; s < nop; ++s) {
    evalg << "   dTf[" << s << "] = Ms[" << Iop[s] - 1
          << "] * (1.0/rho*dTomega[" << s << "] + omega[" << s << "]/(rho*T));"
          << endl;
  }
  evalg << endl;

  // close function
  evalg << endl << "}" << endl << endl;

  /*****************
   *   getSecondDerivative_f
   *****************/
  evalg << "void ammsockNLP::getSecondDerivative_f(const Number T, const "
           "Number Y["
        << nop << "]," << endl;
  evalg << "					Number f[" << nop
        << "], Number dYf[" << nop << "][" << nop << "], Number dTf[" << nop
        << "], Number dYYf[" << nop << "][" << nop << "][" << nop
        << "], Number dYTf[" << nop << "][" << nop << "]," << endl;
  evalg << "					Number H[" << nspec
        << "], Number dTH[" << nspec << "], Number dTTH[" << nspec << "]) {"
        << endl
        << endl;

  evalg << "   //allocate memory" << endl;
  evalg << "   Number dTTf[" << nop << "];" << endl;
  evalg << "   Number rho, dYrho[" << nop << "], dTrho, dYYrho[" << nop << "]["
        << nop << "], dYTrho[" << nop << "], dTTrho;" << endl;
  evalg << "   Number Mbar, dYMbar[" << nop << "], dYYMbar[" << nop << "]["
        << nop << "];" << endl;
  evalg << "   Number q[" << nreac << "], dYq[" << nreac << "][" << nop
        << "], dTq[" << nreac << "],  dYYq[" << nreac << "][" << nop << "]["
        << nop << "], dYTq[" << nreac << "][" << nop << "], dTTq[" << nreac
        << "];" << endl;
  evalg << "   Number qtilde[" << nreac << "], dYqtilde[" << nreac << "]["
        << nop << "], dTqtilde[" << nreac << "], dYYqtilde[" << nreac << "]["
        << nop << "][" << nop << "], dYTqtilde[" << nreac << "][" << nop
        << "], dTTqtilde[" << nreac << "];" << endl;
  evalg << "   Number omega[" << nop << "], dYomega[" << nop << "][" << nop
        << "], dTomega[" << nop << "], dYYomega[" << nop << "][" << nop << "]["
        << nop << "], dYTomega[" << nop << "][" << nop << "], dTTomega[" << nop
        << "];" << endl;
  evalg << "   Number M[" << ntb << "], dYM[" << ntb << "][" << nop << "], dTM["
        << ntb << "], dYYM[" << ntb << "][" << nop << "][" << nop << "], dYTM["
        << ntb << "][" << nop << "], dTTM[" << ntb << "];" << endl;
  evalg << "   Number Gp[" << nreac << "], dYGp[" << nreac << "][" << nop
        << "], dYYGp[" << nreac << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number Gm[" << nreac << "], dYGm[" << nreac << "][" << nop
        << "], dYYGm[" << nreac << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number Rp[" << nreac << "], dYRp[" << nreac << "][" << nop
        << "], dYYRp[" << nreac << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number Rm[" << nreac << "], dYRm[" << nreac << "][" << nop
        << "], dYYRm[" << nreac << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number kf[" << nreac << "], dTkf[" << nreac << "], dTTkf["
        << nreac << "];" << endl;
  evalg << "   Number kr[" << nreac << "], dTkr[" << nreac << "], dTTkr["
        << nreac << "];" << endl;
  evalg << endl;

  evalg << "   //call overloaded function" << endl;
  evalg << "   "
           "getSecondDerivative_f(T,Y,f,dYf,dTf,dYYf,dYTf,dTTf,rho,dYrho,dTrho,"
           "dYYrho,dYTrho,dTTrho,Mbar,dYMbar,dYYMbar,q,dYq,dTq,dYYq,dYTq,dTTq,"
           "qtilde,dYqtilde,dTqtilde,dYYqtilde,dYTqtilde,dTTqtilde,omega,"
           "dYomega,dTomega,dYYomega,dYTomega,dTTomega,M,dYM,dTM,dYYM,dYTM,"
           "dTTM,Gp,dYGp,dYYGp,Gm,dYGm,dYYGm,Rp,dYRp,dYYRp,Rm,dYRm,dYYRm,kf,"
           "dTkf,dTTkf,kr,dTkr,dTTkr,H,dTH,dTTH);"
        << endl;
  evalg << endl;

  // close function
  evalg << endl << "}" << endl << endl;

  evalg << "void ammsockNLP::getSecondDerivative_f(const Number T, const "
           "Number _Y["
        << nop << "]," << endl;
  evalg << "					Number f[" << nop
        << "], Number dYf[" << nop << "][" << nop << "], Number dTf[" << nop
        << "], Number dYYf[" << nop << "][" << nop << "][" << nop
        << "], Number dYTf[" << nop << "][" << nop << "], Number dTTf[" << nop
        << "]," << endl;
  evalg << "					Number H[" << nspec
        << "], Number dTH[" << nspec << "], Number dTTH[" << nspec
        << "],  Number Yres[" << nnop << "], Number dYYres[" << nnop << "]["
        << nop << "]) {" << endl
        << endl;

  evalg << "   //allocate memory" << endl;
  evalg << "   Number rho, dYrho[" << nop << "], dTrho, dYYrho[" << nop << "]["
        << nop << "], dYTrho[" << nop << "], dTTrho;" << endl;
  evalg << "   Number Mbar, dYMbar[" << nop << "], dYYMbar[" << nop << "]["
        << nop << "];" << endl;
  evalg << "   Number q[" << nreac << "], dYq[" << nreac << "][" << nop
        << "], dTq[" << nreac << "],  dYYq[" << nreac << "][" << nop << "]["
        << nop << "], dYTq[" << nreac << "][" << nop << "], dTTq[" << nreac
        << "];" << endl;
  evalg << "   Number qtilde[" << nreac << "], dYqtilde[" << nreac << "]["
        << nop << "], dTqtilde[" << nreac << "], dYYqtilde[" << nreac << "]["
        << nop << "][" << nop << "], dYTqtilde[" << nreac << "][" << nop
        << "], dTTqtilde[" << nreac << "];" << endl;
  evalg << "   Number omega[" << nop << "], dYomega[" << nop << "][" << nop
        << "], dTomega[" << nop << "], dYYomega[" << nop << "][" << nop << "]["
        << nop << "], dYTomega[" << nop << "][" << nop << "], dTTomega[" << nop
        << "];" << endl;
  evalg << "   Number M[" << ntb << "], dYM[" << ntb << "][" << nop << "], dTM["
        << ntb << "], dYYM[" << ntb << "][" << nop << "][" << nop << "], dYTM["
        << ntb << "][" << nop << "], dTTM[" << ntb << "];" << endl;
  evalg << "   Number Gp[" << nreac << "], dYGp[" << nreac << "][" << nop
        << "], dYYGp[" << nreac << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number Gm[" << nreac << "], dYGm[" << nreac << "][" << nop
        << "], dYYGm[" << nreac << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number Rp[" << nreac << "], dYRp[" << nreac << "][" << nop
        << "], dYYRp[" << nreac << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number Rm[" << nreac << "], dYRm[" << nreac << "][" << nop
        << "], dYYRm[" << nreac << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number kf[" << nreac << "], dTkf[" << nreac << "], dTTkf["
        << nreac << "];" << endl;
  evalg << "   Number kr[" << nreac << "], dTkr[" << nreac << "], dTTkr["
        << nreac << "];" << endl;

  evalg << "   //set resolved species and their derivatives" << endl;
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Yres[" << i << "] = Y" << Inop[i] - 1 << "RES;" << endl;
  }
  evalg << endl;
  evalg << "   //define derivatives of resolutions" << endl;
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Number dYY" << i << "[" << nop << "] =  DIFFY" << Inop[i] - 1
          << "RES;" << endl;
  }
  for (int i = 0; i < nnop; ++i) {
    for (int j = 0; j < nop; ++j) {
      evalg << "   dYYres[" << i << "][" << j << "] = dYY" << i << "[" << j
            << "];" << endl;
    }
  }
  evalg << endl;

  evalg << "   //call overloaded function" << endl;
  evalg << "   "
           "getSecondDerivative_f(T,_Y,f,dYf,dTf,dYYf,dYTf,dTTf,rho,dYrho,"
           "dTrho,dYYrho,dYTrho,dTTrho,Mbar,dYMbar,dYYMbar,q,dYq,dTq,dYYq,dYTq,"
           "dTTq,qtilde,dYqtilde,dTqtilde,dYYqtilde,dYTqtilde,dTTqtilde,omega,"
           "dYomega,dTomega,dYYomega,dYTomega,dTTomega,M,dYM,dTM,dYYM,dYTM,"
           "dTTM,Gp,dYGp,dYYGp,Gm,dYGm,dYYGm,Rp,dYRp,dYYRp,Rm,dYRm,dYYRm,kf,"
           "dTkf,dTTkf,kr,dTkr,dTTkr,H,dTH,dTTH);"
        << endl;
  evalg << endl;

  // close function
  evalg << endl << "}" << endl << endl;

  evalg << "void ammsockNLP::getSecondDerivative_f(const Number T, const "
           "Number _Y["
        << nop << "]," << endl;
  evalg << "					Number f[" << nop
        << "], Number dYf[" << nop << "][" << nop << "], Number dTf[" << nop
        << "], Number dYYf[" << nop << "][" << nop << "][" << nop
        << "], Number dYTf[" << nop << "][" << nop << "], Number dTTf[" << nop
        << "]," << endl;
  evalg << "					Number &rho, Number dYrho["
        << nop << "], Number &dTrho, Number dYYrho[" << nop << "][" << nop
        << "], Number dYTrho[" << nop << "], Number &dTTrho," << endl;
  evalg << "					Number &Mbar, Number dYMbar["
        << nop << "], Number dYYMbar[" << nop << "][" << nop << "]," << endl;
  evalg << "					Number q[" << nreac
        << "], Number dYq[" << nreac << "][" << nop << "], Number dTq[" << nreac
        << "],  Number dYYq[" << nreac << "][" << nop << "][" << nop
        << "], Number dYTq[" << nreac << "][" << nop << "], Number dTTq["
        << nreac << "]," << endl;
  evalg << "					Number qtilde[" << nreac
        << "], Number dYqtilde[" << nreac << "][" << nop
        << "], Number dTqtilde[" << nreac << "], Number dYYqtilde[" << nreac
        << "][" << nop << "][" << nop << "], Number dYTqtilde[" << nreac << "]["
        << nop << "], Number dTTqtilde[" << nreac << "]," << endl;
  evalg << "					Number omega[" << nop
        << "], Number dYomega[" << nop << "][" << nop << "], Number dTomega["
        << nop << "], Number dYYomega[" << nop << "][" << nop << "][" << nop
        << "], Number dYTomega[" << nop << "][" << nop << "], Number dTTomega["
        << nop << "]," << endl;
  evalg << "					Number M[" << ntb
        << "], Number dYM[" << ntb << "][" << nop << "], Number dTM[" << ntb
        << "], Number dYYM[" << ntb << "][" << nop << "][" << nop
        << "], Number dYTM[" << ntb << "][" << nop << "], Number dTTM[" << ntb
        << "]," << endl;
  evalg << "					Number Gp[" << nreac
        << "], Number dYGp[" << nreac << "][" << nop << "], Number dYYGp["
        << nreac << "][" << nop << "][" << nop << "]," << endl;
  evalg << "					Number Gm[" << nreac
        << "], Number dYGm[" << nreac << "][" << nop << "], Number dYYGm["
        << nreac << "][" << nop << "][" << nop << "]," << endl;
  evalg << "					Number Rp[" << nreac
        << "], Number dYRp[" << nreac << "][" << nop << "], Number dYYRp["
        << nreac << "][" << nop << "][" << nop << "]," << endl;
  evalg << "					Number Rm[" << nreac
        << "], Number dYRm[" << nreac << "][" << nop << "], Number dYYRm["
        << nreac << "][" << nop << "][" << nop << "]," << endl;
  evalg << "					Number kf[" << nreac
        << "], Number dTkf[" << nreac << "], Number dTTkf[" << nreac << "],"
        << endl;
  evalg << "					Number kr[" << nreac
        << "], Number dTkr[" << nreac << "], Number dTTkr[" << nreac << "],"
        << endl;
  evalg << "					Number H[" << nspec
        << "], Number dTH[" << nspec << "], Number dTTH[" << nspec << "]) {"
        << endl
        << endl;

  // get variables and molar weights
  evalg << "   // Preliminaries" << endl;
  evalg << "   Number Y[" << nspec << "];" << endl;
  for (int i = 0; i < nop; ++i) {
    evalg << "   Y[" << Iop[i] - 1 << "] = _Y[" << i << "];" << endl;
  }
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Y[" << Inop[i] - 1 << "] = Y" << Inop[i] - 1 << "RES;" << endl;
  }

  evalg << "   Number Ms[" << nspec << "] = { " << std::setprecision(15)
        << 1e-3 * Ms[0];
  for (int i = 1; i < Ms.size(); ++i) {
    evalg << ", " << 1e-3 * Ms[i];
  }
  evalg << "}; //molar weights in kg/mol" << endl;
  evalg << endl;

  evalg << "   //define derivatives of resolutions" << endl;
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Number dYY" << Inop[i] - 1 << "[" << nop << "] =  DIFFY"
          << Inop[i] - 1 << "RES;" << endl;
  }
  evalg << endl;

  // get first derivative
  evalg << "   //get first derivatives" << endl;
  evalg
      << "   "
         "getFirstDerivative_f(T,_Y,f,dYf,dTf,rho,dYrho,dTrho,Mbar,dYMbar,q,"
         "dYq,dTq,qtilde,dYqtilde,dTqtilde,omega,dYomega,dTomega,M,dYM,dTM,Gp,"
         "dYGp,Gm,dYGm,Rp,dYRp,Rm,dYRm,kf,dTkf,dTTkf,kr,dTkr,dTTkr,H,dTH,dTTH);"
      << endl;
  evalg << endl;

  // generating dYYrho
  evalg << "   // Generate dTTrho and dYYrho" << endl;
  evalg << "   dTTrho = 2*rho/(T*T);" << endl;
  for (int s = 0; s < nop; ++s) {
    for (int m = 0; m < nop; ++m) {
      evalg << "   dYYrho[" << s << "][" << m << "] = -( dYMbar[" << m
            << "] * rho + Mbar * dYrho[" << m << "]) * (1.0/Ms[" << Iop[s] - 1
            << "]";
      for (int i = 0; i < nnop; ++i) {
        evalg << " + 1.0/Ms[" << Inop[i] - 1 << "] * dYY" << Inop[i] - 1 << "["
              << s << "]";
      }
      evalg << ");" << endl;
    }
    evalg << endl;
  }

  // generating dYYrho
  evalg << "   // Generate dYYMbar" << endl;
  for (int s = 0; s < nop; ++s) {
    for (int m = 0; m < nop; ++m) {
      evalg << "   dYYMbar[" << s << "][" << m
            << "] = 2*Mbar*Mbar*Mbar * (1.0/Ms[" << Iop[s] - 1 << "]";
      for (int i = 0; i < nnop; ++i) {
        evalg << " + 1.0/Ms[" << Inop[i] - 1 << "] * dYY" << Inop[i] - 1 << "["
              << s << "]";
      }
      evalg << ") * (1.0/Ms[" << Iop[m] - 1 << "]";
      for (int i = 0; i < nnop; ++i) {
        evalg << " + 1.0/Ms[" << Inop[i] - 1 << "] * dYY" << Inop[i] - 1 << "["
              << m << "]";
      }
      evalg << ");" << endl;
    }
    evalg << endl;
  }

  // generating dYM and dYYM
  evalg << "   // Generate dTTM and dYYM" << endl;
  evalg << "   Number sumAlphaYM = 0.0;" << endl;
  for (int k = 0; k < bodyCoeff.size(); ++k) {
    evalg << "   // third body #" << k + 1 << endl;
    evalg << "   dTTM[" << k << "] = 2*M[" << k << "]/(T*T);" << endl;
    evalg << "   sumAlphaYM = 0.0 ";
    for (int s = 0; s < nspec; ++s) {
      evalg << " + " << bodyCoeff[k][s] << " * Y[" << s << "]/Ms[" << s << "]";
    }
    evalg << ";" << endl;
    for (int s = 0; s < nop; ++s) {
      for (int m = 0; m < nop; ++m) {
        evalg << "   dYYM[" << k << "][" << s << "][" << m << "] = dYYrho[" << s
              << "][" << m << "]*sumAlphaYM + dYrho[" << s << "]*("
              << bodyCoeff[k][Iop[m] - 1] << "/Ms[" << Iop[m] - 1 << "]";
        for (int i = 0; i < nnop; ++i) {
          evalg << " + " << bodyCoeff[k][Inop[i] - 1] << "/Ms[" << Inop[i] - 1
                << "] * dYY" << Inop[i] - 1 << "[" << m << "]";
        }
        evalg << ") + dYrho[" << m << "]*(" << bodyCoeff[k][Iop[s] - 1]
              << "/Ms[" << Iop[s] - 1 << "]";
        for (int i = 0; i < nnop; ++i) {
          evalg << " + " << bodyCoeff[k][Inop[i] - 1] << "/Ms[" << Inop[i] - 1
                << "] * dYY" << Inop[i] - 1 << "[" << s << "]";
        }
        evalg << ");" << endl;
      }
    }
  }
  evalg << endl;

  evalg << "   // Generate dYYG" << endl;
  for (int r = 0; r < nreac; ++r) {
    for (int s = 0; s < nop; ++s) {
      for (int m = 0; m < nop; ++m) {
        evalg << "   dYYGp[" << r << "][" << s << "][" << m << "] = 0.0";
        if (s != m) {
          if ((nuprime[Iop[s] - 1][r] != 0) && (nuprime[Iop[m] - 1][r] != 0)) {
            evalg << " + (" << nuprime[Iop[m] - 1][r] << ")/Ms[" << Iop[m] - 1
                  << "] * pow(Y[" << Iop[m] - 1 << "]/Ms[" << Iop[m] - 1 << "],"
                  << nuprime[Iop[m] - 1][r] - 1 << ") * ("
                  << nuprime[Iop[s] - 1][r] << ")/Ms[" << Iop[s] - 1
                  << "] * pow(Y[" << Iop[s] - 1 << "]/Ms[" << Iop[s] - 1 << "],"
                  << nuprime[Iop[s] - 1][r] - 1 << ")";
            for (int i = 0; i < nop; ++i) {
              if ((i != s) && (i != m)) {
                for (int l = 1; l <= nuprime[Iop[i] - 1][r]; ++l) {
                  evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                        << "]";
                }
              }
            }
          }
        } else {
          if (nuprime[Iop[s] - 1][r] > 1) {
            evalg << " + (" << nuprime[Iop[m] - 1][r] << ")*("
                  << nuprime[Iop[m] - 1][r] - 1 << ")/Ms[" << Iop[m] - 1
                  << "]/Ms[" << Iop[m] - 1 << "] * pow(Y[" << Iop[m] - 1
                  << "]/Ms[" << Iop[m] - 1 << "]," << nuprime[Iop[m] - 1][r] - 2
                  << ")";
            for (int i = 0; i < nop; ++i) {
              if (i != s) {
                for (int l = 1; l <= nuprime[Iop[i] - 1][r]; ++l) {
                  evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                        << "]";
                }
              }
            }
          }
        }
        evalg << ";" << endl;
      }
    }
  }
  for (int r = 0; r < nreac; ++r) {
    for (int s = 0; s < nop; ++s) {
      for (int m = 0; m < nop; ++m) {
        evalg << "   dYYGm[" << r << "][" << s << "][" << m << "] = 0.0";
        if (s != m) {
          if ((nu2prime[Iop[s] - 1][r] != 0) &&
              (nu2prime[Iop[m] - 1][r] != 0)) {
            evalg << " + (" << nu2prime[Iop[m] - 1][r] << ")/Ms[" << Iop[m] - 1
                  << "] * pow(Y[" << Iop[m] - 1 << "]/Ms[" << Iop[m] - 1 << "],"
                  << nu2prime[Iop[m] - 1][r] - 1 << ") * ("
                  << nu2prime[Iop[s] - 1][r] << ")/Ms[" << Iop[s] - 1
                  << "] * pow(Y[" << Iop[s] - 1 << "]/Ms[" << Iop[s] - 1 << "],"
                  << nu2prime[Iop[s] - 1][r] - 1 << ")";
            for (int i = 0; i < nop; ++i) {
              if ((i != s) && (i != m)) {
                for (int l = 1; l <= nu2prime[Iop[i] - 1][r]; ++l) {
                  evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                        << "]";
                }
              }
            }
          }
        } else {
          if (nu2prime[Iop[s] - 1][r] > 1) {
            evalg << " + (" << nu2prime[Iop[m] - 1][r] << ")*("
                  << nu2prime[Iop[m] - 1][r] - 1 << ")/Ms[" << Iop[m] - 1
                  << "]/Ms[" << Iop[m] - 1 << "] * pow(Y[" << Iop[m] - 1
                  << "]/Ms[" << Iop[m] - 1 << "],"
                  << nu2prime[Iop[m] - 1][r] - 2 << ")";
            for (int i = 0; i < nop; ++i) {
              if (i != s) {
                for (int l = 1; l <= nu2prime[Iop[i] - 1][r]; ++l) {
                  evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                        << "]";
                }
              }
            }
          }
        }
        evalg << ";" << endl;
      }
    }
  }
  evalg << endl;

  evalg << "   // Generate dYYR" << endl;
  for (int r = 0; r < nreac; ++r) {
    for (int s = 0; s < nop; ++s) {
      for (int m = 0; m < nop; ++m) {
        evalg << "   dYYRp[" << r << "][" << s << "][" << m << "] = 0.0";
        for (int i = 0; i < nnop; ++i) {
          if (nuprime[Inop[i] - 1][r] != 0) {
            evalg << " + (" << nuprime[Inop[i] - 1][r] << ")/pow(Ms["
                  << Inop[i] - 1 << "]," << nuprime[Inop[i] - 1][r] << ") * ( ("
                  << nuprime[Inop[i] - 1][r] - 1 << ") * pow(Y[" << Inop[i] - 1
                  << "]," << nuprime[Inop[i] - 1][r] - 2 << ") * dYY"
                  << Inop[i] - 1 << "[" << s << "] * dYY" << Inop[i] - 1 << "["
                  << m << "]";
            for (int j = 0; j < nnop; ++j) {
              if ((nuprime[Inop[j] - 1][r] != 0) && (j != i)) {
                evalg << " * pow(Y[" << Inop[j] - 1 << "]/Ms[" << Inop[j] - 1
                      << "]," << nuprime[Inop[j] - 1][r] << ")";
              }
            }
            evalg << " + pow(Y[" << Inop[i] - 1 << "],"
                  << nuprime[Inop[i] - 1][r] - 1 << ") * dYY" << Inop[i] - 1
                  << "[" << s << "] * (0.0";
            for (int l = 0; l < nnop; ++l) {
              if (l != i) {
                if (nuprime[Inop[l] - 1][r] != 0) {
                  evalg << " + (" << nuprime[Inop[l] - 1][r] << ")/Ms["
                        << Inop[l] - 1 << "] * pow(Y[" << Inop[l] - 1 << "]/Ms["
                        << Inop[l] - 1 << "]," << nuprime[Inop[l] - 1][r] - 1
                        << ") * dYY" << Inop[l] - 1 << "[" << m << "]";
                  for (int k = 0; k < nnop; ++k) {
                    if ((nuprime[Inop[k] - 1][r] != 0) && (k != i) &&
                        (k != l)) {
                      evalg << " * pow(Y[" << Inop[k] - 1 << "]/Ms["
                            << Inop[k] - 1 << "]," << nuprime[Inop[k] - 1][r]
                            << ")";
                    }
                  }
                }
              }
            }
            evalg << "))";
          }
        }
        evalg << ";" << endl;
      }
    }
  }
  evalg << endl;
  for (int r = 0; r < nreac; ++r) {
    for (int s = 0; s < nop; ++s) {
      for (int m = 0; m < nop; ++m) {
        evalg << "   dYYRm[" << r << "][" << s << "][" << m << "] = 0.0";
        for (int i = 0; i < nnop; ++i) {
          if (nu2prime[Inop[i] - 1][r] != 0) {
            evalg << " + (" << nu2prime[Inop[i] - 1][r] << ")/pow(Ms["
                  << Inop[i] - 1 << "]," << nu2prime[Inop[i] - 1][r]
                  << ") * ( (" << nu2prime[Inop[i] - 1][r] - 1 << ") * pow(Y["
                  << Inop[i] - 1 << "]," << nu2prime[Inop[i] - 1][r] - 2
                  << ") * dYY" << Inop[i] - 1 << "[" << s << "] * dYY"
                  << Inop[i] - 1 << "[" << m << "]";
            for (int j = 0; j < nnop; ++j) {
              if ((nu2prime[Inop[j] - 1][r] != 0) && (j != i)) {
                evalg << " * pow(Y[" << Inop[j] - 1 << "]/Ms[" << Inop[j] - 1
                      << "]," << nu2prime[Inop[j] - 1][r] << ")";
              }
            }
            evalg << " + pow(Y[" << Inop[i] - 1 << "],"
                  << nu2prime[Inop[i] - 1][r] - 1 << ") * dYY" << Inop[i] - 1
                  << "[" << s << "] * (0.0";
            for (int l = 0; l < nnop; ++l) {
              if (l != i) {
                if (nu2prime[Inop[l] - 1][r] != 0) {
                  evalg << " + (" << nu2prime[Inop[l] - 1][r] << ")/Ms["
                        << Inop[l] - 1 << "] * pow(Y[" << Inop[l] - 1 << "]/Ms["
                        << Inop[l] - 1 << "]," << nu2prime[Inop[l] - 1][r] - 1
                        << ") * dYY" << Inop[l] - 1 << "[" << m << "]";
                  for (int k = 0; k < nnop; ++k) {
                    if ((nu2prime[Inop[k] - 1][r] != 0) && (k != i) &&
                        (k != l)) {
                      evalg << " * pow(Y[" << Inop[k] - 1 << "]/Ms["
                            << Inop[k] - 1 << "]," << nu2prime[Inop[k] - 1][r]
                            << ")";
                    }
                  }
                }
              }
            }
            evalg << "))";
          }
        }
        evalg << ";" << endl;
      }
    }
  }
  evalg << endl;

  // generating dYYqtilde
  evalg << endl << "   // Generate dYYqtilde" << endl;
  for (int i = 0; i < nreac; ++i) {
    int nubarprime = 0;
    int nubar2prime = 0;
    for (int s = 0; s < nspec; ++s) {
      nubarprime += nuprime[s][i];
      nubar2prime += nu2prime[s][i];
    }

    for (int s = 0; s < nop; ++s) {
      for (int m = 0; m < nop; ++m) {
        evalg << "   dYYqtilde[" << i << "][" << s << "][" << m << "]  = kf["
              << i << "] * ( Gp[" << i << "] * ((" << nubarprime
              << ") * ( pow(rho," << nubarprime - 1 << ") * (dYrho[" << s
              << "] * dYRp[" << i << "][" << m << "] + dYrho[" << m
              << "] * dYRp[" << i << "][" << s << "] + dYYrho[" << s << "]["
              << m << "] * Rp[" << i << "])";
        evalg << " + (" << nubarprime - 1 << ") * pow(rho," << nubarprime - 2
              << ") * dYrho[" << m << "] * dYrho[" << s << "] * Rp[" << i
              << "]) + pow(rho," << nubarprime << ") * dYYRp[" << i << "][" << s
              << "][" << m << "])";
        evalg << " + dYGp[" << i << "][" << s << "] * ( (" << nubarprime
              << ") * pow(rho," << nubarprime - 1 << ") *dYrho[" << m
              << "] * Rp[" << i << "] + pow(rho," << nubarprime << ") * dYRp["
              << i << "][" << m << "])";
        evalg << " + dYGp[" << i << "][" << m << "] * ( (" << nubarprime
              << ") * pow(rho," << nubarprime - 1 << ") *dYrho[" << s
              << "] * Rp[" << i << "] + pow(rho," << nubarprime << ") * dYRp["
              << i << "][" << s << "])";
        evalg << " + dYYGp[" << i << "][" << s << "][" << m << "] * pow(rho,"
              << nubarprime << ") * Rp[" << i << "] )";
        evalg << " - kr[" << i << "] * ( Gm[" << i << "] * ((" << nubar2prime
              << ") * ( pow(rho," << nubar2prime - 1 << ") * (dYrho[" << s
              << "] * dYRm[" << i << "][" << m << "] + dYrho[" << m
              << "] * dYRm[" << i << "][" << s << "] + dYYrho[" << s << "]["
              << m << "] * Rm[" << i << "])";
        evalg << " + (" << nubar2prime - 1 << ") * pow(rho," << nubar2prime - 2
              << ") * dYrho[" << m << "] * dYrho[" << s << "] * Rm[" << i
              << "]) + pow(rho," << nubar2prime << ") * dYYRm[" << i << "]["
              << s << "][" << m << "])";
        evalg << " + dYGm[" << i << "][" << s << "] * ( (" << nubar2prime
              << ") * pow(rho," << nubar2prime - 1 << ") *dYrho[" << m
              << "] * Rm[" << i << "] + pow(rho," << nubar2prime << ") * dYRm["
              << i << "][" << m << "])";
        evalg << " + dYGm[" << i << "][" << m << "] * ( (" << nubar2prime
              << ") * pow(rho," << nubar2prime - 1 << ") *dYrho[" << s
              << "] * Rm[" << i << "] + pow(rho," << nubar2prime << ") * dYRm["
              << i << "][" << s << "])";
        evalg << " + dYYGm[" << i << "][" << s << "][" << m << "] * pow(rho,"
              << nubar2prime << ") * Rm[" << i << "]);" << endl;
      }
      evalg << endl;
    }
    evalg << endl;
  }

  // generating dTTqtilde
  evalg << endl << "   // Generate dTTqtilde" << endl;
  for (int i = 0; i < nreac; ++i) {
    int nubarprime = 0;
    int nubar2prime = 0;
    for (int s = 0; s < nspec; ++s) {
      nubarprime += nuprime[s][i];
      nubar2prime += nu2prime[s][i];
    }
    evalg << "   dTTqtilde[" << i << "]  = (dTTkf[" << i << "] - 2*("
          << nubarprime << ")/T * dTkf[" << i << "] + ((" << nubarprime << ")+("
          << nubarprime << ")*(" << nubarprime << "))/(T*T) * kf[" << i
          << "]) * pow(rho," << nubarprime << ") * Gp[" << i << "] * Rp[" << i
          << "]";
    evalg << "- (dTTkr[" << i << "] - 2*(" << nubar2prime << ")/T * dTkr[" << i
          << "] + ((" << nubar2prime << ")+(" << nubar2prime << ")*("
          << nubar2prime << "))/(T*T) * kr[" << i << "]) * pow(rho,"
          << nubar2prime << ") * Gm[" << i << "] * Rm[" << i << "];" << endl;
  }

  // generating dYYq
  evalg << endl << "   // Generate dYYq" << endl;
  for (int i = 0; i < nreac; ++i) {
    int ind = thirdBodyOccurs(bodyPos, i);

    // if there isn't a thrid body
    if (ind == -1) {
      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          evalg << "   dYYq[" << i << "][" << s << "][" << m << "] = dYYqtilde["
                << i << "][" << s << "][" << m << "];" << endl;
        }
      }
      // otherwise use product rule
    } else {
      int whichThirdBody = bodyNumber[ind] - 1;
      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          evalg << "   dYYq[" << i << "][" << s << "][" << m << "] = M["
                << whichThirdBody << "] * dYYqtilde[" << i << "][" << s << "]["
                << m << "] + dYM[" << whichThirdBody << "][" << s
                << "] * dYqtilde[" << i << "][" << m << "] + dYM["
                << whichThirdBody << "][" << m << "] * dYqtilde[" << i << "]["
                << s << "] + dYYM[" << whichThirdBody << "][" << s << "][" << m
                << "]*qtilde[" << i << "];" << endl;
        }
      }
    }
    evalg << endl;
  }

  // generating dTTq
  evalg << endl << "   // Generate dTTq" << endl;
  for (int i = 0; i < nreac; ++i) {
    int ind = thirdBodyOccurs(bodyPos, i);

    // if there isn't a thrid body
    if (ind == -1) {
      evalg << "   dTTq[" << i << "] = dTTqtilde[" << i << "];" << endl;
      // otherwise use product rule
    } else {
      int whichThirdBody = bodyNumber[ind] - 1;
      evalg << "   dTTq[" << i << "] = M[" << whichThirdBody << "] * dTTqtilde["
            << i << "] + 2*dTM[" << whichThirdBody << "] * dTqtilde[" << i
            << "] + dTTM[" << whichThirdBody << "]*qtilde[" << i << "];"
            << endl;
    }
    evalg << endl;
  }

  // generating dYYomega
  evalg << endl << "   // Generate dYYomega" << endl;
  for (int i = 0; i < nop; ++i) {
    for (int s = 0; s < nop; ++s) {
      for (int m = 0; m < nop; ++m) {
        evalg << "   dYYomega[" << i << "][" << s << "][" << m << "]  = 0.0";
        for (int r = 0; r < nreac; ++r) {
          if (nu[Iop[i] - 1][r] != 0)
            evalg << " + (" << nu[Iop[i] - 1][r] << ") * dYYq[" << r << "]["
                  << s << "][" << m << "]";
        }
        evalg << ";" << endl;
      }
      evalg << endl;
    }
    evalg << endl;
  }
  evalg << endl;

  // generating dTTomega
  evalg << endl << "   // Generate dTTomega" << endl;
  for (int i = 0; i < nop; ++i) {
    evalg << "   dTTomega[" << i << "] = 0.0";
    for (int r = 0; r < nreac; ++r) {
      if (nu[Iop[i] - 1][r] != 0)
        evalg << " + (" << nu[Iop[i] - 1][r] << ") * dTTq[" << r << "]";
    }
    evalg << ";" << endl;
  }
  evalg << endl;

  // generating dYYf
  evalg << endl << "   // Generate dYYf" << endl;
  for (int i = 0; i < nop; ++i) {
    for (int s = 0; s < nop; ++s) {
      for (int m = 0; m < nop; ++m) {
        evalg << "   dYYf[" << i << "][" << s << "][" << m << "]  = Ms["
              << Iop[i] - 1 << "] * ( 2.0/(rho*rho*rho) * omega[" << i
              << "] * dYrho[" << s << "] * dYrho[" << m
              << "] - 1.0/(rho*rho) * ( dYrho[" << m << "] * dYomega[" << i
              << "][" << s << "] + dYrho[" << s << "] * dYomega[" << i << "]["
              << m << "] + omega[" << i << "] * dYYrho[" << s << "][" << m
              << "]) + 1/rho * dYYomega[" << i << "][" << s << "][" << m
              << "]);" << endl;
      }
      evalg << endl;
    }
    evalg << endl;
  }
  evalg << endl;

  // generating dTTf
  evalg << endl << "   // Generate dTTf" << endl;
  for (int i = 0; i < nop; ++i) {
    evalg << "   dTTf[" << i << "]  = Ms[" << Iop[i] - 1
          << "]/rho * ( dTTomega[" << i << "] + 2/T * dTomega[" << i << "] );"
          << endl;
  }
  evalg << endl;

  // generating dYTrho
  evalg << endl << "   // Generate dYTrho" << endl;
  for (int s = 0; s < nop; ++s) {
    evalg << "   dYTrho[" << s << "] =- dYrho[" << s << "]/T;" << endl;
  }
  evalg << endl;

  // generating dTM
  evalg << "   // Generate dYTM" << endl;
  for (int k = 0; k < bodyCoeff.size(); ++k) {
    evalg << "   // third body #" << k + 1 << endl;
    for (int s = 0; s < nop; ++s) {
      evalg << "   dYTM[" << k << "][" << s << "] = -dYM[" << k << "][" << s
            << "]/T;" << endl;
    }
  }

  // generating dYTqtilde
  evalg << endl << "   // Generate dYTqtilde" << endl;
  for (int i = 0; i < nreac; ++i) {
    int nubarprime = 0;
    int nubar2prime = 0;
    for (int s = 0; s < nspec; ++s) {
      nubarprime += nuprime[s][i];
      nubar2prime += nu2prime[s][i];
    }

    for (int s = 0; s < nop; ++s) {
      evalg << "   dYTqtilde[" << i << "][" << s << "]  = ( dTkf[" << i
            << "] - kf[" << i << "]*(" << nubarprime << ")/T )  * ( Gp[" << i
            << "] * ( (" << nubarprime << ") * pow(rho," << nubarprime - 1
            << ") * dYrho[" << s << "] * Rp[" << i << "] + pow(rho,"
            << nubarprime << ") * dYRp[" << i << "][" << s << "]) + dYGp[" << i
            << "][" << s << "] * pow(rho," << nubarprime << ") * Rp[" << i
            << "])";
      evalg << " - ( dTkr[" << i << "] - kr[" << i << "]*(" << nubar2prime
            << ")/T )  * ( Gm[" << i << "] * ( (" << nubar2prime
            << ") * pow(rho," << nubar2prime - 1 << ") * dYrho[" << s
            << "] * Rm[" << i << "] + pow(rho," << nubar2prime << ") * dYRm["
            << i << "][" << s << "]) + dYGm[" << i << "][" << s
            << "] * pow(rho," << nubar2prime << ") * Rm[" << i << "] );"
            << endl;
    }
    evalg << endl;
  }

  // generating dYTq
  evalg << endl << "   // Generate dYTq" << endl;
  for (int i = 0; i < nreac; ++i) {
    int ind = thirdBodyOccurs(bodyPos, i);
    // if there isn't a thrid body
    if (ind == -1) {
      for (int s = 0; s < nop; ++s) {
        evalg << "   dYTq[" << i << "][" << s << "] = dYTqtilde[" << i << "]["
              << s << "];" << endl;
      }
      // otherwise use product rule
    } else {
      int whichThirdBody = bodyNumber[ind] - 1;
      for (int s = 0; s < nop; ++s) {
        evalg << "   dYTq[" << i << "][" << s << "] = dYM[" << whichThirdBody
              << "][" << s << "] * dTqtilde[" << i << "] + dYTM["
              << whichThirdBody << "][" << s << "] * qtilde[" << i << "] + dTM["
              << whichThirdBody << "] *dYqtilde[" << i << "][" << s << "] + M["
              << whichThirdBody << "] * dYTqtilde[" << i << "][" << s << "];"
              << endl;
      }
    }
    evalg << endl;
  }

  // generating dYTomega
  evalg << endl << "   // Generate dYTomega" << endl;
  for (int i = 0; i < nop; ++i) {
    for (int s = 0; s < nop; ++s) {
      evalg << "   dYTomega[" << i << "][" << s << "]  = 0.0";
      for (int r = 0; r < nreac; ++r) {
        if (nu[Iop[i] - 1][r] != 0)
          evalg << " + (" << nu[Iop[i] - 1][r] << ") * dYTq[" << r << "][" << s
                << "]";
      }
      evalg << ";" << endl;
    }
    evalg << endl;
  }
  evalg << endl;

  // generating dYTf
  evalg << endl << "   // Generate dYTf" << endl;
  for (int i = 0; i < nop; ++i) {
    for (int m = 0; m < nop; ++m) {
      evalg << "   dYTf[" << i << "][" << m << "]  = Ms[" << Iop[i] - 1
            << "]/rho * ( dYTomega[" << i << "][" << m << "] + dYomega[" << i
            << "][" << m << "]/T - dYrho[" << m << "]/rho * ( dTomega[" << i
            << "] + omega[" << i << "]/T) );" << endl;
    }
    evalg << endl;
  }

  // close function
  evalg << endl << "}" << endl;

  /*****************
   *   getThridDerivative_f
   *****************/

  evalg << "void ammsockNLP::getThirdDerivative_f(const Number T, const Number "
           "_Y["
        << nop << "]," << endl;
  evalg << "					Number f[" << nop
        << "], Number dYf[" << nop << "][" << nop << "], Number dTf[" << nop
        << "], Number dYYf[" << nop << "][" << nop << "][" << nop
        << "], Number dYTf[" << nop << "][" << nop << "], Number dTTf[" << nop
        << "], Number dYYYf[" << nop << "][" << nop << "][" << nop << "]["
        << nop << "], Number dYYTf[" << nop << "][" << nop << "][" << nop
        << "], Number dYTTf[" << nop << "][" << nop << "]," << endl;
  evalg << "					Number H[" << nspec
        << "], Number dTH[" << nspec << "], Number dTTH[" << nspec
        << "], Number Yres[" << nnop << "], Number dYYres[" << nnop << "]["
        << nop << "]) {" << endl
        << endl;

  evalg << "   Number rho, dYrho[" << nop << "], dTrho, dYYrho[" << nop << "]["
        << nop << "], dYTrho[" << nop << "], dTTrho, dYYYrho[" << nop << "]["
        << nop << "][" << nop << "];" << endl;
  evalg << "   Number Mbar, dYMbar[" << nop << "], dYYMbar[" << nop << "]["
        << nop << "];" << endl;
  evalg << "   Number q[" << nreac << "], dYq[" << nreac << "][" << nop
        << "], dTq[" << nreac << "],  dYYq[" << nreac << "][" << nop << "]["
        << nop << "], dYTq[" << nreac << "][" << nop << "], dTTq[" << nreac
        << "], dYYYq[" << nreac << "][" << nop << "][" << nop << "][" << nop
        << "], dYYTq[" << nreac << "][" << nop << "][" << nop << "], dYTTq["
        << nreac << "][" << nop << "];" << endl;
  evalg << "   Number qtilde[" << nreac << "], dYqtilde[" << nreac << "]["
        << nop << "], dTqtilde[" << nreac << "], dYYqtilde[" << nreac << "]["
        << nop << "][" << nop << "], dYTqtilde[" << nreac << "][" << nop
        << "], dTTqtilde[" << nreac << "], dYYYqtilde[" << nreac << "][" << nop
        << "][" << nop << "][" << nop << "], dYYTqtilde[" << nreac << "]["
        << nop << "][" << nop << "], dYTTqtilde[" << nreac << "][" << nop
        << "];" << endl;
  evalg << "   Number omega[" << nop << "], dYomega[" << nop << "][" << nop
        << "], dTomega[" << nop << "], dYYomega[" << nop << "][" << nop << "]["
        << nop << "], dYTomega[" << nop << "][" << nop << "], dTTomega[" << nop
        << "], dYYYomega[" << nop << "][" << nop << "][" << nop << "][" << nop
        << "], dYYTomega[" << nop << "][" << nop << "][" << nop
        << "], dYTTomega[" << nop << "][" << nop << "];" << endl;
  evalg << "   Number M[" << ntb << "], dYM[" << ntb << "][" << nop << "], dTM["
        << ntb << "], dYYM[" << ntb << "][" << nop << "][" << nop << "], dYTM["
        << ntb << "][" << nop << "], dTTM[" << ntb << "], dYYYM[" << ntb << "]["
        << nop << "][" << nop << "][" << nop << "], dYYTM[" << ntb << "]["
        << nop << "][" << nop << "], dYTTM[" << ntb << "][" << nop << "];"
        << endl;
  evalg << "   Number Gp[" << nreac << "], dYGp[" << nreac << "][" << nop
        << "], dYYGp[" << nreac << "][" << nop << "][" << nop << "], dYYYGp["
        << nreac << "][" << nop << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number Gm[" << nreac << "], dYGm[" << nreac << "][" << nop
        << "], dYYGm[" << nreac << "][" << nop << "][" << nop << "], dYYYGm["
        << nreac << "][" << nop << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number Rp[" << nreac << "], dYRp[" << nreac << "][" << nop
        << "], dYYRp[" << nreac << "][" << nop << "][" << nop << "], dYYYRp["
        << nreac << "][" << nop << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number Rm[" << nreac << "], dYRm[" << nreac << "][" << nop
        << "], dYYRm[" << nreac << "][" << nop << "][" << nop << "], dYYYRm["
        << nreac << "][" << nop << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number kf[" << nreac << "], dTkf[" << nreac << "], dTTkf["
        << nreac << "];" << endl;
  evalg << "   Number kr[" << nreac << "], dTkr[" << nreac << "], dTTkr["
        << nreac << "];" << endl;

  evalg << "   //set resolved species and their derivatives" << endl;
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Yres[" << i << "] = Y" << Inop[i] - 1 << "RES;" << endl;
  }
  evalg << endl;
  evalg << "   //define derivatives of resolutions" << endl;
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Number dYY" << i << "[" << nop << "] =  DIFFY" << Inop[i] - 1
          << "RES;" << endl;
  }
  for (int i = 0; i < nnop; ++i) {
    for (int j = 0; j < nop; ++j) {
      evalg << "   dYYres[" << i << "][" << j << "] = dYY" << i << "[" << j
            << "];" << endl;
    }
  }
  evalg << endl;

  evalg
      << "   "
         "getThirdDerivative_f(T,_Y,f,dYf,dTf,dYYf,dYTf,dTTf,dYYYf,dYYTf,dYTTf,"
         "rho,dYrho,dTrho,dYYrho,dYTrho,dTTrho,dYYYrho,Mbar,dYMbar,dYYMbar,q,"
         "dYq,dTq,dYYq,dYTq,dTTq,dYYYq,dYYTq,dYTTq,qtilde,dYqtilde,dTqtilde,"
         "dYYqtilde,dYTqtilde,dTTqtilde,dYYYqtilde,dYYTqtilde,dYTTqtilde,omega,"
         "dYomega,dTomega,dYYomega,dYTomega,dTTomega,dYYYomega,dYYTomega,"
         "dYTTomega,M,dYM,dTM,dYYM,dYTM,dTTM,dYYYM,dYYTM,dYTTM,Gp,dYGp,dYYGp,"
         "dYYYGp,Gm,dYGm,dYYGm,dYYYGm,Rp,dYRp,dYYRp,dYYYRp,Rm,dYRm,dYYRm,"
         "dYYYRm,kf,dTkf,dTTkf,kr,dTkr,dTTkr,H,dTH,dTTH);"
      << endl;

  // close function
  evalg << endl << "}" << endl << endl;

  evalg << "void ammsockNLP::getThirdDerivative_f(const Number T, const Number "
           "_Y["
        << nop << "]," << endl;
  evalg << "					Number f[" << nop
        << "], Number dYf[" << nop << "][" << nop << "], Number dTf[" << nop
        << "], Number dYYf[" << nop << "][" << nop << "][" << nop
        << "], Number dYTf[" << nop << "][" << nop << "], Number dTTf[" << nop
        << "], Number dYYYf[" << nop << "][" << nop << "][" << nop << "]["
        << nop << "], Number dYYTf[" << nop << "][" << nop << "][" << nop
        << "], Number dYTTf[" << nop << "][" << nop << "]," << endl;
  evalg << "					Number &rho, Number dYrho["
        << nop << "], Number &dTrho, Number dYYrho[" << nop << "][" << nop
        << "], Number dYTrho[" << nop << "], Number &dTTrho, Number dYYYrho["
        << nop << "][" << nop << "][" << nop << "]," << endl;
  evalg << "					Number &Mbar, Number dYMbar["
        << nop << "], Number dYYMbar[" << nop << "][" << nop << "]," << endl;
  evalg << "					Number q[" << nreac
        << "], Number dYq[" << nreac << "][" << nop << "], Number dTq[" << nreac
        << "],  Number dYYq[" << nreac << "][" << nop << "][" << nop
        << "], Number dYTq[" << nreac << "][" << nop << "], Number dTTq["
        << nreac << "], Number dYYYq[" << nreac << "][" << nop << "][" << nop
        << "][" << nop << "], Number dYYTq[" << nreac << "][" << nop << "]["
        << nop << "], Number dYTTq[" << nreac << "][" << nop << "]," << endl;
  evalg << "					Number qtilde[" << nreac
        << "], Number dYqtilde[" << nreac << "][" << nop
        << "], Number dTqtilde[" << nreac << "], Number dYYqtilde[" << nreac
        << "][" << nop << "][" << nop << "], Number dYTqtilde[" << nreac << "]["
        << nop << "], Number dTTqtilde[" << nreac << "], Number dYYYqtilde["
        << nreac << "][" << nop << "][" << nop << "][" << nop
        << "], Number dYYTqtilde[" << nreac << "][" << nop << "][" << nop
        << "], Number dYTTqtilde[" << nreac << "][" << nop << "]," << endl;
  evalg << "					Number omega[" << nop
        << "], Number dYomega[" << nop << "][" << nop << "], Number dTomega["
        << nop << "], Number dYYomega[" << nop << "][" << nop << "][" << nop
        << "], Number dYTomega[" << nop << "][" << nop << "], Number dTTomega["
        << nop << "], Number dYYYomega[" << nop << "][" << nop << "][" << nop
        << "][" << nop << "], Number dYYTomega[" << nop << "][" << nop << "]["
        << nop << "], Number dYTTomega[" << nop << "][" << nop << "]," << endl;
  evalg << "					Number M[" << ntb
        << "], Number dYM[" << ntb << "][" << nop << "], Number dTM[" << ntb
        << "], Number dYYM[" << ntb << "][" << nop << "][" << nop
        << "], Number dYTM[" << ntb << "][" << nop << "], Number dTTM[" << ntb
        << "], Number dYYYM[" << ntb << "][" << nop << "][" << nop << "]["
        << nop << "], Number dYYTM[" << ntb << "][" << nop << "][" << nop
        << "], Number dYTTM[" << ntb << "][" << nop << "]," << endl;
  evalg << "					Number Gp[" << nreac
        << "], Number dYGp[" << nreac << "][" << nop << "], Number dYYGp["
        << nreac << "][" << nop << "][" << nop << "], Number dYYYGp[" << nreac
        << "][" << nop << "][" << nop << "][" << nop << "]," << endl;
  evalg << "					Number Gm[" << nreac
        << "], Number dYGm[" << nreac << "][" << nop << "], Number dYYGm["
        << nreac << "][" << nop << "][" << nop << "], Number dYYYGm[" << nreac
        << "][" << nop << "][" << nop << "][" << nop << "]," << endl;
  evalg << "					Number Rp[" << nreac
        << "], Number dYRp[" << nreac << "][" << nop << "], Number dYYRp["
        << nreac << "][" << nop << "][" << nop << "], Number dYYYRp[" << nreac
        << "][" << nop << "][" << nop << "][" << nop << "]," << endl;
  evalg << "					Number Rm[" << nreac
        << "], Number dYRm[" << nreac << "][" << nop << "], Number dYYRm["
        << nreac << "][" << nop << "][" << nop << "], Number dYYYRm[" << nreac
        << "][" << nop << "][" << nop << "][" << nop << "]," << endl;
  evalg << "					Number kf[" << nreac
        << "], Number dTkf[" << nreac << "], Number dTTkf[" << nreac << "],"
        << endl;
  evalg << "					Number kr[" << nreac
        << "], Number dTkr[" << nreac << "], Number dTTkr[" << nreac << "],"
        << endl;
  evalg << "					Number H[" << nspec
        << "], Number dTH[" << nspec << "], Number dTTH[" << nspec << "]) {"
        << endl
        << endl;
  if (EXACTHESSIAN) {
    // get variables and molar weights
    evalg << "   // Preliminaries" << endl;
    evalg << "   Number Y[" << nspec << "];" << endl;
    for (int i = 0; i < nop; ++i) {
      evalg << "   Y[" << Iop[i] - 1 << "] = _Y[" << i << "];" << endl;
    }
    for (int i = 0; i < nnop; ++i) {
      evalg << "   Y[" << Inop[i] - 1 << "] = Y" << Inop[i] - 1 << "RES;"
            << endl;
    }
    evalg << "   //define derivatives of resolutions" << endl;
    for (int i = 0; i < nnop; ++i) {
      evalg << "   Number dYY" << Inop[i] - 1 << "[" << nop << "] =  DIFFY"
            << Inop[i] - 1 << "RES;" << endl;
    }

    evalg << "   Number Ms[" << nspec << "] = { " << std::setprecision(15)
          << 1e-3 * Ms[0];
    for (int i = 1; i < Ms.size(); ++i) {
      evalg << ", " << 1e-3 * Ms[i];
    }
    evalg << "}; //molar weights in kg/mol" << endl;
    evalg << endl;

    evalg << "   //get secound derivatives" << endl;
    evalg << "   "
             "getSecondDerivative_f(T,_Y,f,dYf,dTf,dYYf,dYTf,dTTf,rho,dYrho,"
             "dTrho,dYYrho,dYTrho,dTTrho,Mbar,dYMbar,dYYMbar,q,dYq,dTq,dYYq,"
             "dYTq,dTTq,qtilde,dYqtilde,dTqtilde,dYYqtilde,dYTqtilde,dTTqtilde,"
             "omega,dYomega,dTomega,dYYomega,dYTomega,dTTomega,M,dYM,dTM,dYYM,"
             "dYTM,dTTM,Gp,dYGp,dYYGp,Gm,dYGm,dYYGm,Rp,dYRp,dYYRp,Rm,dYRm,"
             "dYYRm,kf,dTkf,dTTkf,kr,dTkr,dTTkr,H,dTH,dTTH);"
          << endl;
    evalg << endl;

    // generating dYYYrho
    evalg << "   // Generate dYYYrho" << endl;
    for (int s = 0; s < nop; ++s) {
      for (int m = 0; m < nop; ++m) {
        for (int k = 0; k < nop; ++k) {
          evalg << "   dYYYrho[" << s << "][" << m << "][" << k
                << "] = -( dYYMbar[" << m << "][" << k << "] * rho + dYMbar["
                << m << "] * dYrho[" << k << "] + dYMbar[" << k << "] * dYrho["
                << m << "] + Mbar * dYYrho[" << m << "][" << k << "]) * (1/Ms["
                << Iop[s] - 1 << "]";
          for (int i = 0; i < nnop; ++i) {
            evalg << " + 1.0/Ms[" << Inop[i] - 1 << "] * dYY" << Inop[i] - 1
                  << "[" << s << "]";
          }
          evalg << ");" << endl;
        }
      }
      evalg << endl;
    }

    // generating dYTTM, dYYTM, dYYYM
    evalg << "   // Generate dYTTM, dYYTM and dYYYM" << endl;
    evalg << "   Number sumAlphaYM = 0.0;" << endl;
    for (int k = 0; k < bodyCoeff.size(); ++k) {
      evalg << "   // third body #" << k + 1 << endl;
      evalg << "   sumAlphaYM = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        evalg << " + " << bodyCoeff[k][s] << " * Y[" << s << "]/Ms[" << s
              << "]";
      }
      evalg << ";" << endl;
      for (int s = 0; s < nop; ++s) {
        evalg << "   dYTTM[" << k << "][" << s << "] = 2/(T*T) * dYM[" << k
              << "][" << s << "];" << endl;
        for (int m = 0; m < nop; ++m) {
          evalg << "   dYYTM[" << k << "][" << s << "][" << m
                << "] = - 1/T * dYYM[" << k << "][" << s << "][" << m << "];"
                << endl;
          for (int l = 0; l < nop; ++l) {
            evalg << "   dYYYM[" << k << "][" << s << "][" << m << "][" << l
                  << "] = dYYYrho[" << s << "][" << m << "][" << l
                  << "]*sumAlphaYM + dYYrho[" << s << "][" << l << "]*("
                  << bodyCoeff[k][Iop[m] - 1] << "/Ms[" << Iop[m] - 1 << "]";
            for (int i = 0; i < nnop; ++i) {
              evalg << " + " << bodyCoeff[k][Inop[i] - 1] << "/Ms["
                    << Inop[i] - 1 << "] * dYY" << Inop[i] - 1 << "[" << m
                    << "]";
            }
            evalg << ") + dYYrho[" << m << "][" << l << "]*("
                  << bodyCoeff[k][Iop[s] - 1] << "/Ms[" << Iop[s] - 1 << "]";
            for (int i = 0; i < nnop; ++i) {
              evalg << " + " << bodyCoeff[k][Inop[i] - 1] << "/Ms["
                    << Inop[i] - 1 << "] * dYY" << Inop[i] - 1 << "[" << s
                    << "]";
            }
            evalg << ") + dYYrho[" << s << "][" << m << "]*("
                  << bodyCoeff[k][Iop[l] - 1] << "/Ms[" << Iop[l] - 1 << "]";
            for (int i = 0; i < nnop; ++i) {
              evalg << " + " << bodyCoeff[k][Inop[i] - 1] << "/Ms["
                    << Inop[i] - 1 << "] * dYY" << Inop[i] - 1 << "[" << l
                    << "]";
            }
            evalg << ");" << endl;
          }
        }
      }
    }
    evalg << endl;

    // generating general terms
    evalg << "   // Generate dYYYG" << endl;
    for (int r = 0; r < nreac; ++r) {
      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          for (int k = 0; k < nop; ++k) {
            evalg << "   dYYYGp[" << r << "][" << s << "][" << m << "][" << k
                  << "] = 0.0";
            if ((s != m) && (m != k) && (s != k)) {
              if ((nuprime[Iop[s] - 1][r] != 0) &&
                  (nuprime[Iop[m] - 1][r] != 0) &&
                  (nuprime[Iop[k] - 1][r] != 0)) {
                evalg << " + (" << nuprime[Iop[m] - 1][r] << ")/Ms["
                      << Iop[m] - 1 << "] * pow(Y[" << Iop[m] - 1 << "]/Ms["
                      << Iop[m] - 1 << "]," << nuprime[Iop[m] - 1][r] - 1
                      << ") * (" << nuprime[Iop[s] - 1][r] << ")/Ms["
                      << Iop[s] - 1 << "] * pow(Y[" << Iop[s] - 1 << "]/Ms["
                      << Iop[s] - 1 << "]," << nuprime[Iop[s] - 1][r] - 1
                      << ") * (" << nuprime[Iop[k] - 1][r] << ")/Ms["
                      << Iop[k] - 1 << "] * pow(Y[" << Iop[k] - 1 << "]/Ms["
                      << Iop[k] - 1 << "]," << nuprime[Iop[k] - 1][r] - 1
                      << ")";
                for (int i = 0; i < nop; ++i) {
                  if ((i != s) && (i != m) && (i != k)) {
                    for (int l = 1; l <= nuprime[Iop[i] - 1][r]; ++l) {
                      evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                            << "]";
                    }
                  }
                }
              }
            }
            if ((s != m) && (s == k)) {
              if ((nuprime[Iop[s] - 1][r] > 1) &&
                  (nuprime[Iop[m] - 1][r] != 0)) {
                evalg << " + (" << nuprime[Iop[s] - 1][r] << ")*("
                      << nuprime[Iop[s] - 1][r] - 1 << ")/(Ms[" << Iop[s] - 1
                      << "]*Ms[" << Iop[s] - 1 << "]) * pow(Y[" << Iop[s] - 1
                      << "]/Ms[" << Iop[s] - 1 << "],"
                      << nuprime[Iop[s] - 1][r] - 2 << ") * ("
                      << nuprime[Iop[m] - 1][r] << ")/Ms[" << Iop[m] - 1
                      << "] * pow(Y[" << Iop[m] - 1 << "]/Ms[" << Iop[m] - 1
                      << "]," << nuprime[Iop[m] - 1][r] - 1 << ")";
                for (int i = 0; i < nop; ++i) {
                  if ((i != s) && (i != m) && (i != k)) {
                    for (int l = 1; l <= nuprime[Iop[i] - 1][r]; ++l) {
                      evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                            << "]";
                    }
                  }
                }
              }
            }
            if ((s != m) && (m == k)) {
              if ((nuprime[Iop[m] - 1][r] > 1) &&
                  (nuprime[Iop[s] - 1][r] != 0)) {
                evalg << " + (" << nuprime[Iop[m] - 1][r] << ")*("
                      << nuprime[Iop[m] - 1][r] - 1 << ")/(Ms[" << Iop[m] - 1
                      << "]*Ms[" << Iop[m] - 1 << "]) * pow(Y[" << Iop[m] - 1
                      << "]/Ms[" << Iop[m] - 1 << "],"
                      << nuprime[Iop[m] - 1][r] - 2 << ") * ("
                      << nuprime[Iop[s] - 1][r] << ")/Ms[" << Iop[s] - 1
                      << "] * pow(Y[" << Iop[s] - 1 << "]/Ms[" << Iop[s] - 1
                      << "]," << nuprime[Iop[s] - 1][r] - 1 << ")";
                for (int i = 0; i < nop; ++i) {
                  if ((i != s) && (i != m) && (i != k)) {
                    for (int l = 1; l <= nuprime[Iop[i] - 1][r]; ++l) {
                      evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                            << "]";
                    }
                  }
                }
              }
            }
            if ((s == m) && (s != k)) {
              if ((nuprime[Iop[m] - 1][r] > 1) &&
                  (nuprime[Iop[k] - 1][r] != 0)) {
                evalg << " + (" << nuprime[Iop[m] - 1][r] << ")*("
                      << nuprime[Iop[m] - 1][r] - 1 << ")/(Ms[" << Iop[m] - 1
                      << "]*Ms[" << Iop[m] - 1 << "]) * pow(Y[" << Iop[m] - 1
                      << "]/Ms[" << Iop[m] - 1 << "],"
                      << nuprime[Iop[m] - 1][r] - 2 << ") * ("
                      << nuprime[Iop[k] - 1][r] << ")/Ms[" << Iop[k] - 1
                      << "] * pow(Y[" << Iop[k] - 1 << "]/Ms[" << Iop[k] - 1
                      << "]," << nuprime[Iop[k] - 1][r] - 1 << ")";
                for (int i = 0; i < nop; ++i) {
                  if ((i != s) && (i != m) && (i != k)) {
                    for (int l = 1; l <= nuprime[Iop[i] - 1][r]; ++l) {
                      evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                            << "]";
                    }
                  }
                }
              }
            }
            if ((s == m) && (m == k)) {
              if ((nuprime[Iop[m] - 1][r] > 2)) {
                evalg << " + (" << nuprime[Iop[m] - 1][r] << ")*("
                      << nuprime[Iop[m] - 1][r] - 1 << ")*("
                      << nuprime[Iop[m] - 1][r] - 2 << ")/(Ms[" << Iop[m] - 1
                      << "]*Ms[" << Iop[m] - 1 << "]*Ms[" << Iop[m] - 1
                      << "]) * pow(Y[" << Iop[m] - 1 << "]/Ms[" << Iop[m] - 1
                      << "]," << nuprime[Iop[m] - 1][r] - 3 << ")";
                for (int i = 0; i < nop; ++i) {
                  if ((i != s) && (i != m) && (i != k)) {
                    for (int l = 1; l <= nuprime[Iop[i] - 1][r]; ++l) {
                      evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                            << "]";
                    }
                  }
                }
              }
            }
            evalg << ";" << endl;
          }
        }
      }
    }
    for (int r = 0; r < nreac; ++r) {
      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          for (int k = 0; k < nop; ++k) {
            evalg << "   dYYYGm[" << r << "][" << s << "][" << m << "][" << k
                  << "] = 0.0";
            if ((s != m) && (m != k) && (s != k)) {
              if ((nu2prime[Iop[s] - 1][r] != 0) &&
                  (nu2prime[Iop[m] - 1][r] != 0) &&
                  (nu2prime[Iop[k] - 1][r] != 0)) {
                evalg << " + (" << nu2prime[Iop[m] - 1][r] << ")/Ms["
                      << Iop[m] - 1 << "] * pow(Y[" << Iop[m] - 1 << "]/Ms["
                      << Iop[m] - 1 << "]," << nu2prime[Iop[m] - 1][r] - 1
                      << ") * (" << nu2prime[Iop[s] - 1][r] << ")/Ms["
                      << Iop[s] - 1 << "] * pow(Y[" << Iop[s] - 1 << "]/Ms["
                      << Iop[s] - 1 << "]," << nu2prime[Iop[s] - 1][r] - 1
                      << ") * (" << nu2prime[Iop[k] - 1][r] << ")/Ms["
                      << Iop[k] - 1 << "] * pow(Y[" << Iop[k] - 1 << "]/Ms["
                      << Iop[k] - 1 << "]," << nu2prime[Iop[k] - 1][r] - 1
                      << ")";
                for (int i = 0; i < nop; ++i) {
                  if ((i != s) && (i != m) && (i != k)) {
                    for (int l = 1; l <= nu2prime[Iop[i] - 1][r]; ++l) {
                      evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                            << "]";
                    }
                  }
                }
              }
            }
            if ((s != m) && (s == k)) {
              if ((nu2prime[Iop[s] - 1][r] > 1) &&
                  (nu2prime[Iop[m] - 1][r] != 0)) {
                evalg << " + (" << nu2prime[Iop[s] - 1][r] << ")*("
                      << nu2prime[Iop[s] - 1][r] - 1 << ")/(Ms[" << Iop[s] - 1
                      << "]*Ms[" << Iop[s] - 1 << "]) * pow(Y[" << Iop[s] - 1
                      << "]/Ms[" << Iop[s] - 1 << "],"
                      << nu2prime[Iop[s] - 1][r] - 2 << ") * ("
                      << nu2prime[Iop[m] - 1][r] << ")/Ms[" << Iop[m] - 1
                      << "] * pow(Y[" << Iop[m] - 1 << "]/Ms[" << Iop[m] - 1
                      << "]," << nu2prime[Iop[m] - 1][r] - 1 << ")";
                for (int i = 0; i < nop; ++i) {
                  if ((i != s) && (i != m) && (i != k)) {
                    for (int l = 1; l <= nu2prime[Iop[i] - 1][r]; ++l) {
                      evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                            << "]";
                    }
                  }
                }
              }
            }
            if ((s != m) && (m == k)) {
              if ((nu2prime[Iop[m] - 1][r] > 1) &&
                  (nu2prime[Iop[s] - 1][r] != 0)) {
                evalg << " + (" << nu2prime[Iop[m] - 1][r] << ")*("
                      << nu2prime[Iop[m] - 1][r] - 1 << ")/(Ms[" << Iop[m] - 1
                      << "]*Ms[" << Iop[m] - 1 << "]) * pow(Y[" << Iop[m] - 1
                      << "]/Ms[" << Iop[m] - 1 << "],"
                      << nu2prime[Iop[m] - 1][r] - 2 << ") * ("
                      << nu2prime[Iop[s] - 1][r] << ")/Ms[" << Iop[s] - 1
                      << "] * pow(Y[" << Iop[s] - 1 << "]/Ms[" << Iop[s] - 1
                      << "]," << nu2prime[Iop[s] - 1][r] - 1 << ")";
                for (int i = 0; i < nop; ++i) {
                  if ((i != s) && (i != m) && (i != k)) {
                    for (int l = 1; l <= nu2prime[Iop[i] - 1][r]; ++l) {
                      evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                            << "]";
                    }
                  }
                }
              }
            }
            if ((s == m) && (s != k)) {
              if ((nu2prime[Iop[m] - 1][r] > 1) &&
                  (nu2prime[Iop[k] - 1][r] != 0)) {
                evalg << " + (" << nu2prime[Iop[m] - 1][r] << ")*("
                      << nu2prime[Iop[m] - 1][r] - 1 << ")/(Ms[" << Iop[m] - 1
                      << "]*Ms[" << Iop[m] - 1 << "]) * pow(Y[" << Iop[m] - 1
                      << "]/Ms[" << Iop[m] - 1 << "],"
                      << nu2prime[Iop[m] - 1][r] - 2 << ") * ("
                      << nu2prime[Iop[k] - 1][r] << ")/Ms[" << Iop[k] - 1
                      << "] * pow(Y[" << Iop[k] - 1 << "]/Ms[" << Iop[k] - 1
                      << "]," << nu2prime[Iop[k] - 1][r] - 1 << ")";
                for (int i = 0; i < nop; ++i) {
                  if ((i != s) && (i != m) && (i != k)) {
                    for (int l = 1; l <= nu2prime[Iop[i] - 1][r]; ++l) {
                      evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                            << "]";
                    }
                  }
                }
              }
            }
            if ((s == m) && (m == k)) {
              if ((nu2prime[Iop[m] - 1][r] > 2)) {
                evalg << " + (" << nu2prime[Iop[m] - 1][r] << ")*("
                      << nu2prime[Iop[m] - 1][r] - 1 << ")*("
                      << nu2prime[Iop[m] - 1][r] - 2 << ")/(Ms[" << Iop[m] - 1
                      << "]*Ms[" << Iop[m] - 1 << "]*Ms[" << Iop[m] - 1
                      << "]) * pow(Y[" << Iop[m] - 1 << "]/Ms[" << Iop[m] - 1
                      << "]," << nu2prime[Iop[m] - 1][r] - 3 << ")";
                for (int i = 0; i < nop; ++i) {
                  if ((i != s) && (i != m) && (i != k)) {
                    for (int l = 1; l <= nu2prime[Iop[i] - 1][r]; ++l) {
                      evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                            << "]";
                    }
                  }
                }
              }
            }
            evalg << ";" << endl;
          }
        }
      }
    }
    evalg << endl;

    // generate rest terms
    evalg << "   // Generate dYYYR" << endl;
    for (int r = 0; r < nreac; ++r) {
      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          for (int k = 0; k < nop; ++k) {
            evalg << "   dYYYRp[" << r << "][" << s << "][" << m << "][" << k
                  << "] = 0.0";
            for (int i = 0; i < nnop; ++i) {
              if (nuprime[Inop[i] - 1][r] != 0) {
                evalg << " + (" << nuprime[Inop[i] - 1][r] << ")/pow(Ms["
                      << Inop[i] - 1 << "]," << nuprime[Inop[i] - 1][r]
                      << ") * ( (" << nuprime[Inop[i] - 1][r] - 1 << ")*("
                      << nuprime[Inop[i] - 1][r] - 2 << ") * pow(Y["
                      << Inop[i] - 1 << "]," << nuprime[Inop[i] - 1][r] - 3
                      << ") * dYY" << Inop[i] - 1 << "[" << s << "] * dYY"
                      << Inop[i] - 1 << "[" << m << "] * dYY" << Inop[i] - 1
                      << "[" << k << "]";
                for (int j = 0; j < nnop; ++j) {
                  if ((nuprime[Inop[j] - 1][r] != 0) && (j != i)) {
                    evalg << " * pow(Y[" << Inop[j] - 1 << "]/Ms["
                          << Inop[j] - 1 << "]," << nuprime[Inop[j] - 1][r]
                          << ")";
                  }
                }
                evalg << " + (" << nuprime[Inop[i] - 1][r] - 1 << ") * pow(Y["
                      << Inop[i] - 1 << "]," << nuprime[Inop[i] - 1][r] - 2
                      << ") * dYY" << Inop[i] - 1 << "[" << s << "] * dYY"
                      << Inop[i] - 1 << "[" << m << "] * (0.0";
                for (int l = 0; l < nnop; ++l) {
                  if (l != i) {
                    if (nuprime[Inop[l] - 1][r] != 0) {
                      evalg << " + (" << nuprime[Inop[l] - 1][r] << ")/Ms["
                            << Inop[l] - 1 << "] * pow(Y[" << Inop[l] - 1
                            << "]/Ms[" << Inop[l] - 1 << "],"
                            << nuprime[Inop[l] - 1][r] - 1 << ") * dYY"
                            << Inop[l] - 1 << "[" << k << "]";
                      for (int k = 0; k < nnop; ++k) {
                        if ((nuprime[Inop[k] - 1][r] != 0) && (k != i) &&
                            (k != l)) {
                          evalg << " * pow(Y[" << Inop[k] - 1 << "]/Ms["
                                << Inop[k] - 1 << "],"
                                << nuprime[Inop[k] - 1][r] << ")";
                        }
                      }
                    }
                  }
                }
                evalg << ") + (" << nuprime[Inop[i] - 1][r] - 1 << ") * pow(Y["
                      << Inop[i] - 1 << "]," << nuprime[Inop[i] - 1][r] - 2
                      << ") * dYY" << Inop[i] - 1 << "[" << s << "] * dYY"
                      << Inop[i] - 1 << "[" << k << "] * (0.0";
                for (int l = 0; l < nnop; ++l) {
                  if (l != i) {
                    if (nuprime[Inop[l] - 1][r] != 0) {
                      evalg << " + (" << nuprime[Inop[l] - 1][r] << ")/Ms["
                            << Inop[l] - 1 << "] * pow(Y[" << Inop[l] - 1
                            << "]/Ms[" << Inop[l] - 1 << "],"
                            << nuprime[Inop[l] - 1][r] - 1 << ") * dYY"
                            << Inop[l] - 1 << "[" << m << "]";
                      for (int k = 0; k < nnop; ++k) {
                        if ((nuprime[Inop[k] - 1][r] != 0) && (k != i) &&
                            (k != l)) {
                          evalg << " * pow(Y[" << Inop[k] - 1 << "]/Ms["
                                << Inop[k] - 1 << "],"
                                << nuprime[Inop[k] - 1][r] << ")";
                        }
                      }
                    }
                  }
                }
                evalg << ") + pow(Y[" << Inop[i] - 1 << "],"
                      << nuprime[Inop[i] - 1][r] - 1 << ") * dYY" << Inop[i] - 1
                      << "[" << s << "] * (0.0";
                for (int l = 0; l < nnop; ++l) {
                  if ((nuprime[Inop[l] - 1][r] != 0) && (l != i)) {
                    evalg << "+ (" << nuprime[Inop[l] - 1][r] << ")/pow(Ms["
                          << Inop[l] - 1 << "]," << nuprime[Inop[l] - 1][r]
                          << ") * ( (" << nuprime[Inop[l] - 1][r] - 1
                          << ") * pow(Y[" << Inop[l] - 1 << "],"
                          << nuprime[Inop[l] - 1][r] - 2 << ") * dYY"
                          << Inop[l] - 1 << "[" << k << "] * dYY" << Inop[l] - 1
                          << "[" << m << "]";
                    for (int j = 0; j < nnop; ++j) {
                      if ((nuprime[Inop[j] - 1][r] != 0) && (j != l) &&
                          (j != i)) {
                        evalg << " * pow(Y[" << Inop[j] - 1 << "]/Ms["
                              << Inop[j] - 1 << "]," << nuprime[Inop[j] - 1][r]
                              << ")";
                      }
                    }
                    evalg << " + pow(Y[" << Inop[l] - 1 << "],"
                          << nuprime[Inop[l] - 1][r] - 1 << ") *  dYY"
                          << Inop[l] - 1 << "[" << m << "] * (0.0";
                    for (int p = 0; p < nnop; ++p) {
                      if ((p != l) && (p != i)) {
                        if (nuprime[Inop[p] - 1][r] != 0) {
                          evalg << " + (" << nuprime[Inop[p] - 1][r] << ")/Ms["
                                << Inop[p] - 1 << "] * pow(Y[" << Inop[p] - 1
                                << "]/Ms[" << Inop[p] - 1 << "],"
                                << nuprime[Inop[p] - 1][r] - 1 << ") * dYY"
                                << Inop[p] - 1 << "[" << k << "]";
                          for (int j = 0; j < nnop; ++j) {
                            if ((nuprime[Inop[j] - 1][r] != 0) && (j != i) &&
                                (j != l) && (j != p)) {
                              evalg << " * pow(Y[" << Inop[j] - 1 << "]/Ms["
                                    << Inop[j] - 1 << "],"
                                    << nuprime[Inop[j] - 1][r] << ")";
                            }
                          }
                        }
                      }
                    }
                    evalg << "))";
                  }
                }
                evalg << "))";
              }
            }
            evalg << ";" << endl;
          }
        }
      }
    }
    evalg << endl;
    for (int r = 0; r < nreac; ++r) {
      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          for (int k = 0; k < nop; ++k) {
            evalg << "   dYYYRm[" << r << "][" << s << "][" << m << "][" << k
                  << "] = 0.0";
            for (int i = 0; i < nnop; ++i) {
              if (nu2prime[Inop[i] - 1][r] != 0) {
                evalg << " + (" << nu2prime[Inop[i] - 1][r] << ")/pow(Ms["
                      << Inop[i] - 1 << "]," << nu2prime[Inop[i] - 1][r]
                      << ") * ( (" << nu2prime[Inop[i] - 1][r] - 1 << ")*("
                      << nu2prime[Inop[i] - 1][r] - 2 << ") * pow(Y["
                      << Inop[i] - 1 << "]," << nu2prime[Inop[i] - 1][r] - 3
                      << ") * dYY" << Inop[i] - 1 << "[" << s << "] * dYY"
                      << Inop[i] - 1 << "[" << m << "] * dYY" << Inop[i] - 1
                      << "[" << k << "]";
                for (int j = 0; j < nnop; ++j) {
                  if ((nu2prime[Inop[j] - 1][r] != 0) && (j != i)) {
                    evalg << " * pow(Y[" << Inop[j] - 1 << "]/Ms["
                          << Inop[j] - 1 << "]," << nu2prime[Inop[j] - 1][r]
                          << ")";
                  }
                }
                evalg << " + (" << nu2prime[Inop[i] - 1][r] - 1 << ") * pow(Y["
                      << Inop[i] - 1 << "]," << nu2prime[Inop[i] - 1][r] - 2
                      << ") * dYY" << Inop[i] - 1 << "[" << s << "] * dYY"
                      << Inop[i] - 1 << "[" << m << "] * (0.0";
                for (int l = 0; l < nnop; ++l) {
                  if (l != i) {
                    if (nu2prime[Inop[l] - 1][r] != 0) {
                      evalg << " + (" << nu2prime[Inop[l] - 1][r] << ")/Ms["
                            << Inop[l] - 1 << "] * pow(Y[" << Inop[l] - 1
                            << "]/Ms[" << Inop[l] - 1 << "],"
                            << nu2prime[Inop[l] - 1][r] - 1 << ") * dYY"
                            << Inop[l] - 1 << "[" << k << "]";
                      for (int k = 0; k < nnop; ++k) {
                        if ((nu2prime[Inop[k] - 1][r] != 0) && (k != i) &&
                            (k != l)) {
                          evalg << " * pow(Y[" << Inop[k] - 1 << "]/Ms["
                                << Inop[k] - 1 << "],"
                                << nu2prime[Inop[k] - 1][r] << ")";
                        }
                      }
                    }
                  }
                }
                evalg << ") + (" << nu2prime[Inop[i] - 1][r] - 1 << ") * pow(Y["
                      << Inop[i] - 1 << "]," << nu2prime[Inop[i] - 1][r] - 2
                      << ") * dYY" << Inop[i] - 1 << "[" << s << "] * dYY"
                      << Inop[i] - 1 << "[" << k << "] * (0.0";
                for (int l = 0; l < nnop; ++l) {
                  if (l != i) {
                    if (nu2prime[Inop[l] - 1][r] != 0) {
                      evalg << " + (" << nu2prime[Inop[l] - 1][r] << ")/Ms["
                            << Inop[l] - 1 << "] * pow(Y[" << Inop[l] - 1
                            << "]/Ms[" << Inop[l] - 1 << "],"
                            << nu2prime[Inop[l] - 1][r] - 1 << ") * dYY"
                            << Inop[l] - 1 << "[" << m << "]";
                      for (int k = 0; k < nnop; ++k) {
                        if ((nu2prime[Inop[k] - 1][r] != 0) && (k != i) &&
                            (k != l)) {
                          evalg << " * pow(Y[" << Inop[k] - 1 << "]/Ms["
                                << Inop[k] - 1 << "],"
                                << nu2prime[Inop[k] - 1][r] << ")";
                        }
                      }
                    }
                  }
                }
                evalg << ") + pow(Y[" << Inop[i] - 1 << "],"
                      << nu2prime[Inop[i] - 1][r] - 1 << ") * dYY"
                      << Inop[i] - 1 << "[" << s << "] * (0.0";
                for (int l = 0; l < nnop; ++l) {
                  if ((nu2prime[Inop[l] - 1][r] != 0) && (l != i)) {
                    evalg << "+ (" << nu2prime[Inop[l] - 1][r] << ")/pow(Ms["
                          << Inop[l] - 1 << "]," << nu2prime[Inop[l] - 1][r]
                          << ") * ( (" << nu2prime[Inop[l] - 1][r] - 1
                          << ") * pow(Y[" << Inop[l] - 1 << "],"
                          << nu2prime[Inop[l] - 1][r] - 2 << ") * dYY"
                          << Inop[l] - 1 << "[" << k << "] * dYY" << Inop[l] - 1
                          << "[" << m << "]";
                    for (int j = 0; j < nnop; ++j) {
                      if ((nu2prime[Inop[j] - 1][r] != 0) && (j != l) &&
                          (j != i)) {
                        evalg << " * pow(Y[" << Inop[j] - 1 << "]/Ms["
                              << Inop[j] - 1 << "]," << nu2prime[Inop[j] - 1][r]
                              << ")";
                      }
                    }
                    evalg << " + pow(Y[" << Inop[l] - 1 << "],"
                          << nu2prime[Inop[l] - 1][r] - 1 << ") *  dYY"
                          << Inop[l] - 1 << "[" << m << "] * (0.0";
                    for (int p = 0; p < nnop; ++p) {
                      if ((p != l) && (p != i)) {
                        if (nu2prime[Inop[p] - 1][r] != 0) {
                          evalg << " + (" << nu2prime[Inop[p] - 1][r] << ")/Ms["
                                << Inop[p] - 1 << "] * pow(Y[" << Inop[p] - 1
                                << "]/Ms[" << Inop[p] - 1 << "],"
                                << nu2prime[Inop[p] - 1][r] - 1 << ") * dYY"
                                << Inop[p] - 1 << "[" << k << "]";
                          for (int j = 0; j < nnop; ++j) {
                            if ((nu2prime[Inop[j] - 1][r] != 0) && (j != i) &&
                                (j != l) && (j != p)) {
                              evalg << " * pow(Y[" << Inop[j] - 1 << "]/Ms["
                                    << Inop[j] - 1 << "],"
                                    << nu2prime[Inop[j] - 1][r] << ")";
                            }
                          }
                        }
                      }
                    }
                    evalg << "))";
                  }
                }
                evalg << "))";
              }
            }
            evalg << ";" << endl;
          }
        }
      }
    }
    evalg << endl;

    // generating dYYYqtilde
    evalg << endl << "   // Generate dYYYqtilde" << endl;
    for (int i = 0; i < nreac; ++i) {
      int nubarprime = 0;
      int nubar2prime = 0;
      for (int s = 0; s < nspec; ++s) {
        nubarprime += nuprime[s][i];
        nubar2prime += nu2prime[s][i];
      }

      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          for (int k = 0; k < nop; ++k) {
            evalg << "   dYYYqtilde[" << i << "][" << s << "][" << m << "]["
                  << k << "]  = kf[" << i << "] * ( pow(rho," << nubarprime
                  << ") * ( dYYYRp[" << i << "][" << s << "][" << m << "][" << k
                  << "] * Gp[" << i << "] + Rp[" << i << "] * dYYYGp[" << i
                  << "][" << s << "][" << m << "][" << k << "]";
            evalg << " + dYYGp[" << i << "][" << s << "][" << k << "] * dYRp["
                  << i << "][" << m << "] + dYYGp[" << i << "][" << m << "]["
                  << k << "] * dYRp[" << i << "][" << s << "] + dYYGp[" << i
                  << "][" << s << "][" << m << "] * dYRp[" << i << "][" << k
                  << "]";
            evalg << " + dYGp[" << i << "][" << s << "] * dYYRp[" << i << "]["
                  << m << "][" << k << "] + dYGp[" << i << "][" << m
                  << "] * dYYRp[" << i << "][" << s << "][" << k << "] + dYGp["
                  << i << "][" << k << "] * dYYRp[" << i << "][" << s << "]["
                  << m << "])";
            evalg << " + (" << nubarprime << ") * pow(rho," << nubarprime - 1
                  << ") * ( Gp[" << i << "] * ( dYrho[" << k << "] * dYYRp["
                  << i << "][" << s << "][" << m << "] + dYrho[" << s
                  << "] * dYYRp[" << i << "][" << m << "][" << k << "] + dYrho["
                  << m << "] * dYYRp[" << i << "][" << s << "][" << k << "]";
            evalg << " + dYYrho[" << s << "][" << k << "] * dYRp[" << i << "]["
                  << m << "] + dYYrho[" << m << "][" << k << "] * dYRp[" << i
                  << "][" << s << "] + dYYrho[" << s << "][" << m << "] * dYRp["
                  << i << "][" << k << "] + dYYYrho[" << s << "][" << m << "]["
                  << k << "] * Rp[" << i << "]";
            evalg << ") + Rp[" << i << "] * ( dYrho[" << k << "] * dYYGp[" << i
                  << "][" << s << "][" << m << "] + dYrho[" << s << "] * dYYGp["
                  << i << "][" << m << "][" << k << "] + dYrho[" << m
                  << "] * dYYGp[" << i << "][" << s << "][" << k << "]";
            evalg << " + dYYrho[" << s << "][" << k << "] * dYGp[" << i << "]["
                  << m << "] + dYYrho[" << m << "][" << k << "] * dYGp[" << i
                  << "][" << s << "] + dYYrho[" << s << "][" << m << "] * dYGp["
                  << i << "][" << k << "])";
            evalg << " + dYGp[" << i << "][" << s << "] * ( dYRp[" << i << "]["
                  << k << "] * dYrho[" << m << "] + dYRp[" << i << "][" << m
                  << "] * dYrho[" << k << "])";
            evalg << " + dYGp[" << i << "][" << m << "] * ( dYRp[" << i << "]["
                  << k << "] * dYrho[" << s << "] + dYRp[" << i << "][" << s
                  << "] * dYrho[" << k << "])";
            evalg << " + dYGp[" << i << "][" << k << "] * ( dYRp[" << i << "]["
                  << m << "] * dYrho[" << s << "] + dYRp[" << i << "][" << s
                  << "] * dYrho[" << m << "]))";
            evalg << " + (" << nubarprime << ") * (" << nubarprime - 1
                  << ") * pow(rho," << nubarprime - 2 << ") * ( Gp[" << i
                  << "] * ( dYRp[" << i << "][" << s << "] * dYrho[" << m
                  << "] * dYrho[" << k << "] + dYRp[" << i << "][" << m
                  << "] * dYrho[" << s << "] * dYrho[" << k << "] + dYRp[" << i
                  << "][" << k << "] * dYrho[" << m << "] * dYrho[" << s << "]";
            evalg << " + (dYrho[" << k << "] * dYYrho[" << s << "][" << m
                  << "] + dYrho[" << s << "] * dYYrho[" << m << "][" << k
                  << "] + dYrho[" << m << "] * dYYrho[" << s << "][" << k
                  << "]) * Rp[" << i << "]";
            evalg << " ) + Rp[" << i << "] * ( dYGp[" << i << "][" << s
                  << "] * dYrho[" << m << "] * dYrho[" << k << "] + dYGp[" << i
                  << "][" << m << "] * dYrho[" << s << "] * dYrho[" << k
                  << "] + dYGp[" << i << "][" << k << "] * dYrho[" << m
                  << "] * dYrho[" << s << "] ))";
            evalg << " + (" << nubarprime << ") * (" << nubarprime - 1
                  << ") * (" << nubarprime - 2 << ") * pow(rho,"
                  << nubarprime - 3 << ") * dYrho[" << s << "] * dYrho[" << m
                  << "] * dYrho[" << k << "] * Gp[" << i << "] * Rp[" << i
                  << "])";
            evalg << " - (kr[" << i << "] * ( pow(rho," << nubar2prime
                  << ") * ( dYYYRm[" << i << "][" << s << "][" << m << "][" << k
                  << "] * Gm[" << i << "] + Rm[" << i << "] * dYYYGm[" << i
                  << "][" << s << "][" << m << "][" << k << "]";
            evalg << " + dYYGm[" << i << "][" << s << "][" << k << "] * dYRm["
                  << i << "][" << m << "] + dYYGm[" << i << "][" << m << "]["
                  << k << "] * dYRm[" << i << "][" << s << "] + dYYGm[" << i
                  << "][" << s << "][" << m << "] * dYRm[" << i << "][" << k
                  << "]";
            evalg << " + dYGm[" << i << "][" << s << "] * dYYRm[" << i << "]["
                  << m << "][" << k << "] + dYGm[" << i << "][" << m
                  << "] * dYYRm[" << i << "][" << s << "][" << k << "] + dYGm["
                  << i << "][" << k << "] * dYYRm[" << i << "][" << s << "]["
                  << m << "])";
            evalg << " + (" << nubar2prime << ") * pow(rho," << nubar2prime - 1
                  << ") * ( Gm[" << i << "] * ( dYrho[" << k << "] * dYYRm["
                  << i << "][" << s << "][" << m << "] + dYrho[" << s
                  << "] * dYYRm[" << i << "][" << m << "][" << k << "] + dYrho["
                  << m << "] * dYYRm[" << i << "][" << s << "][" << k << "]";
            evalg << " + dYYrho[" << s << "][" << k << "] * dYRm[" << i << "]["
                  << m << "] + dYYrho[" << m << "][" << k << "] * dYRm[" << i
                  << "][" << s << "] + dYYrho[" << s << "][" << m << "] * dYRm["
                  << i << "][" << k << "] + dYYYrho[" << s << "][" << m << "]["
                  << k << "] * Rm[" << i << "]";
            evalg << ") + Rm[" << i << "] * ( dYrho[" << k << "] * dYYGm[" << i
                  << "][" << s << "][" << m << "] + dYrho[" << s << "] * dYYGm["
                  << i << "][" << m << "][" << k << "] + dYrho[" << m
                  << "] * dYYGm[" << i << "][" << s << "][" << k << "]";
            evalg << " + dYYrho[" << s << "][" << k << "] * dYGm[" << i << "]["
                  << m << "] + dYYrho[" << m << "][" << k << "] * dYGm[" << i
                  << "][" << s << "] + dYYrho[" << s << "][" << m << "] * dYGm["
                  << i << "][" << k << "])";
            evalg << " + dYGm[" << i << "][" << s << "] * ( dYRm[" << i << "]["
                  << k << "] * dYrho[" << m << "] + dYRm[" << i << "][" << m
                  << "] * dYrho[" << k << "])";
            evalg << " + dYGm[" << i << "][" << m << "] * ( dYRm[" << i << "]["
                  << k << "] * dYrho[" << s << "] + dYRm[" << i << "][" << s
                  << "] * dYrho[" << k << "])";
            evalg << " + dYGm[" << i << "][" << k << "] * ( dYRm[" << i << "]["
                  << m << "] * dYrho[" << s << "] + dYRm[" << i << "][" << s
                  << "] * dYrho[" << m << "]))";
            evalg << " + (" << nubar2prime << ") * (" << nubar2prime - 1
                  << ") * pow(rho," << nubar2prime - 2 << ") * ( Gm[" << i
                  << "] * ( dYRm[" << i << "][" << s << "] * dYrho[" << m
                  << "] * dYrho[" << k << "] + dYRm[" << i << "][" << m
                  << "] * dYrho[" << s << "] * dYrho[" << k << "] + dYRm[" << i
                  << "][" << k << "] * dYrho[" << m << "] * dYrho[" << s << "]";
            evalg << " + (dYrho[" << k << "] * dYYrho[" << s << "][" << m
                  << "] + dYrho[" << s << "] * dYYrho[" << m << "][" << k
                  << "] + dYrho[" << m << "] * dYYrho[" << s << "][" << k
                  << "]) * Rm[" << i << "]";
            evalg << " ) + Rm[" << i << "] * ( dYGm[" << i << "][" << s
                  << "] * dYrho[" << m << "] * dYrho[" << k << "] + dYGm[" << i
                  << "][" << m << "] * dYrho[" << s << "] * dYrho[" << k
                  << "] + dYGm[" << i << "][" << k << "] * dYrho[" << m
                  << "] * dYrho[" << s << "] ))";
            evalg << " + (" << nubar2prime << ") * (" << nubar2prime - 1
                  << ") * (" << nubar2prime - 2 << ") * pow(rho,"
                  << nubar2prime - 3 << ") * dYrho[" << s << "] * dYrho[" << m
                  << "] * dYrho[" << k << "] * Gm[" << i << "] * Rm[" << i
                  << "]))";
            evalg << ";" << endl;
          }
        }
        evalg << endl;
      }
      evalg << endl;
    }

    // generating dYYTqtilde
    evalg << endl << "   // Generate dYYTqtilde" << endl;
    for (int i = 0; i < nreac; ++i) {
      int nubarprime = 0;
      int nubar2prime = 0;
      for (int s = 0; s < nspec; ++s) {
        nubarprime += nuprime[s][i];
        nubar2prime += nu2prime[s][i];
      }

      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          evalg << "   dYYTqtilde[" << i << "][" << s << "][" << m
                << "] = (dTkf[" << i << "] - (" << nubarprime << ")/T * kf["
                << i << "]) * ( pow(rho," << nubarprime << ") * ( dYYGp[" << i
                << "][" << s << "][" << m << "] * Rp[" << i << "] + dYGp[" << i
                << "][" << s << "] * dYRp[" << i << "][" << m << "] + dYGp["
                << i << "][" << m << "] * dYRp[" << i << "][" << s << "] + Gp["
                << i << "] * dYYRp[" << i << "][" << s << "][" << m << "])";
          evalg << " + (" << nubarprime << ") * pow(rho," << nubarprime - 1
                << ") * ( Rp[" << i << "] * ( Gp[" << i << "] * dYYrho[" << s
                << "][" << m << "] + dYGp[" << i << "][" << s << "] * dYrho["
                << m << "] + dYGp[" << i << "][" << m << "] * dYrho[" << s
                << "]) + Gp[" << i << "] * (dYrho[" << s << "] * dYRp[" << i
                << "][" << m << "] + dYrho[" << m << "] * dYRp[" << i << "]["
                << s << "]) )";
          evalg << " + (" << nubarprime << ") * (" << nubarprime - 1
                << ") * pow(rho," << nubarprime - 2 << ") * dYrho[" << m
                << "] * dYrho[" << s << "] * Gp[" << i << "] * Rp[" << i
                << "])";
          evalg << " - (dTkr[" << i << "] - (" << nubar2prime << ")/T * kr["
                << i << "]) * ( pow(rho," << nubar2prime << ") * ( dYYGm[" << i
                << "][" << s << "][" << m << "] * Rm[" << i << "] + dYGm[" << i
                << "][" << s << "] * dYRm[" << i << "][" << m << "] + dYGm["
                << i << "][" << m << "] * dYRm[" << i << "][" << s << "] + Gm["
                << i << "] * dYYRm[" << i << "][" << s << "][" << m << "])";
          evalg << " + (" << nubar2prime << ") * pow(rho," << nubar2prime - 1
                << ") * ( Rm[" << i << "] * ( Gm[" << i << "] * dYYrho[" << s
                << "][" << m << "] + dYGm[" << i << "][" << s << "] * dYrho["
                << m << "] + dYGm[" << i << "][" << m << "] * dYrho[" << s
                << "]) + Gm[" << i << "] * (dYrho[" << s << "] * dYRm[" << i
                << "][" << m << "] + dYrho[" << m << "] * dYRm[" << i << "]["
                << s << "]) )";
          evalg << " + (" << nubar2prime << ") * (" << nubar2prime - 1
                << ") * pow(rho," << nubar2prime - 2 << ") * dYrho[" << m
                << "] * dYrho[" << s << "] * Gm[" << i << "] * Rm[" << i
                << "]);";
        }
        evalg << endl;
      }
      evalg << endl;
    }

    // generating dYTTqtilde
    evalg << endl << "   // Generate dYYTqtilde" << endl;
    for (int i = 0; i < nreac; ++i) {
      int nubarprime = 0;
      int nubar2prime = 0;
      for (int s = 0; s < nspec; ++s) {
        nubarprime += nuprime[s][i];
        nubar2prime += nu2prime[s][i];
      }

      for (int s = 0; s < nop; ++s) {
        evalg << "   dYTTqtilde[" << i << "][" << s << "] = (dTTkf[" << i
              << "] - 2*(" << nubarprime << ")/T * dTkf[" << i << "] + (("
              << nubarprime << ")+(" << nubarprime << ")*(" << nubarprime
              << "))/(T*T) * kf[" << i << "]) * ( pow(rho," << nubarprime
              << ") * ( dYGp[" << i << "][" << s << "] * Rp[" << i << "] + Gp["
              << i << "] * dYRp[" << i << "][" << s << "]) + (" << nubarprime
              << ") * pow(rho," << nubarprime - 1 << ") * dYrho[" << s
              << "] * Gp[" << i << "] * Rp[" << i << "] )";
        evalg << " - (dTTkr[" << i << "] - 2*(" << nubar2prime << ")/T * dTkr["
              << i << "] + ((" << nubar2prime << ")+(" << nubar2prime << ")*("
              << nubar2prime << "))/(T*T) * kr[" << i << "]) * ( pow(rho,"
              << nubar2prime << ") * ( dYGm[" << i << "][" << s << "] * Rm["
              << i << "] + Gm[" << i << "] * dYRm[" << i << "][" << s
              << "]) + (" << nubar2prime << ") * pow(rho," << nubar2prime - 1
              << ") * dYrho[" << s << "] * Gm[" << i << "] * Rm[" << i
              << "] );";
        evalg << endl;
      }
      evalg << endl;
    }

    // generating dYYYq
    evalg << endl << "   // Generate dYYYq" << endl;
    for (int i = 0; i < nreac; ++i) {
      int ind = thirdBodyOccurs(bodyPos, i);

      // if there isn't a thrid body
      if (ind == -1) {
        for (int s = 0; s < nop; ++s) {
          for (int m = 0; m < nop; ++m) {
            for (int k = 0; k < nop; ++k) {
              evalg << "   dYYYq[" << i << "][" << s << "][" << m << "][" << k
                    << "] = dYYYqtilde[" << i << "][" << s << "][" << m << "]["
                    << k << "];" << endl;
            }
          }
        }
        // otherwise use product rule
      } else {
        int whichThirdBody = bodyNumber[ind] - 1;
        for (int s = 0; s < nop; ++s) {
          for (int m = 0; m < nop; ++m) {
            for (int k = 0; k < nop; ++k) {
              evalg << "   dYYYq[" << i << "][" << s << "][" << m << "][" << k
                    << "] = M[" << whichThirdBody << "] * dYYYqtilde[" << i
                    << "][" << s << "][" << m << "][" << k << "] + dYM["
                    << whichThirdBody << "][" << k << "] * dYYqtilde[" << i
                    << "][" << s << "][" << m << "] + dYM[" << whichThirdBody
                    << "][" << m << "] * dYYqtilde[" << i << "][" << s << "]["
                    << k << "] + dYM[" << whichThirdBody << "][" << s
                    << "] * dYYqtilde[" << i << "][" << m << "][" << k
                    << "] + dYYM[" << whichThirdBody << "][" << s << "][" << m
                    << "] * dYqtilde[" << i << "][" << k << "] + dYYM["
                    << whichThirdBody << "][" << s << "][" << k
                    << "] * dYqtilde[" << i << "][" << m << "] + dYYM["
                    << whichThirdBody << "][" << m << "][" << k
                    << "] * dYqtilde[" << i << "][" << s << "] + dYYYM["
                    << whichThirdBody << "][" << s << "][" << m << "][" << k
                    << "] * qtilde[" << i << "];" << endl;
            }
          }
        }
      }
      evalg << endl;
    }

    // generating dYYTq
    evalg << endl << "   // Generate dYYTq" << endl;
    for (int i = 0; i < nreac; ++i) {
      int ind = thirdBodyOccurs(bodyPos, i);

      // if there isn't a thrid body
      if (ind == -1) {
        for (int s = 0; s < nop; ++s) {
          for (int m = 0; m < nop; ++m) {
            evalg << "   dYYTq[" << i << "][" << s << "][" << m
                  << "] = dYYTqtilde[" << i << "][" << s << "][" << m << "];"
                  << endl;
          }
        }
        // otherwise use product rule
      } else {
        int whichThirdBody = bodyNumber[ind] - 1;
        for (int s = 0; s < nop; ++s) {
          for (int m = 0; m < nop; ++m) {
            evalg << "   dYYTq[" << i << "][" << s << "][" << m << "] = M["
                  << whichThirdBody << "] * dYYTqtilde[" << i << "][" << s
                  << "][" << m << "] + dTM[" << whichThirdBody
                  << "] * dYYqtilde[" << i << "][" << s << "][" << m
                  << "] + dYM[" << whichThirdBody << "][" << m
                  << "] * dYTqtilde[" << i << "][" << s << "] + dYM["
                  << whichThirdBody << "][" << s << "] * dYTqtilde[" << i
                  << "][" << m << "] + dYYM[" << whichThirdBody << "][" << s
                  << "][" << m << "] * dTqtilde[" << i << "] + dYTM["
                  << whichThirdBody << "][" << s << "] * dYqtilde[" << i << "]["
                  << m << "] + dYTM[" << whichThirdBody << "][" << m
                  << "] * dYqtilde[" << i << "][" << s << "] + dYYTM["
                  << whichThirdBody << "][" << s << "][" << m << "] * qtilde["
                  << i << "];" << endl;
          }
        }
      }
      evalg << endl;
    }

    // generating dYTTq
    evalg << endl << "   // Generate dYTTq" << endl;
    for (int i = 0; i < nreac; ++i) {
      int ind = thirdBodyOccurs(bodyPos, i);

      // if there isn't a thrid body
      if (ind == -1) {
        for (int s = 0; s < nop; ++s) {
          evalg << "   dYTTq[" << i << "][" << s << "] = dYTTqtilde[" << i
                << "][" << s << "];" << endl;
        }
        // otherwise use product rule
      } else {
        int whichThirdBody = bodyNumber[ind] - 1;
        for (int s = 0; s < nop; ++s) {
          evalg << "   dYTTq[" << i << "][" << s << "] = M[" << whichThirdBody
                << "] * dYTTqtilde[" << i << "][" << s << "] + 2 * dTM["
                << whichThirdBody << "] * dYTqtilde[" << i << "][" << s
                << "] + dYM[" << whichThirdBody << "][" << s << "] * dTTqtilde["
                << i << "] + 2 * dYTM[" << whichThirdBody << "][" << s
                << "] * dTqtilde[" << i << "] + dTTM[" << whichThirdBody
                << "] * dYqtilde[" << i << "][" << s << "] + dYTTM["
                << whichThirdBody << "][" << s << "] * qtilde[" << i << "];"
                << endl;
        }
      }
      evalg << endl;
    }

    // generating dYYYomega
    evalg << endl << "   // Generate dYYYomega" << endl;
    for (int i = 0; i < nop; ++i) {
      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          for (int k = 0; k < nop; ++k) {
            evalg << "   dYYYomega[" << i << "][" << s << "][" << m << "][" << k
                  << "] = 0.0";
            for (int r = 0; r < nreac; ++r) {
              if (nu[Iop[i] - 1][r] != 0)
                evalg << " + (" << nu[Iop[i] - 1][r] << ") * dYYYq[" << r
                      << "][" << s << "][" << m << "][" << k << "]";
            }
            evalg << ";" << endl;
          }
        }
        evalg << endl;
      }
      evalg << endl;
    }
    evalg << endl;

    // generating dYYTomega
    evalg << endl << "   // Generate dYYTomega" << endl;
    for (int i = 0; i < nop; ++i) {
      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          evalg << "   dYYTomega[" << i << "][" << s << "][" << m << "] = 0.0";
          for (int r = 0; r < nreac; ++r) {
            if (nu[Iop[i] - 1][r] != 0)
              evalg << " + (" << nu[Iop[i] - 1][r] << ") * dYYTq[" << r << "]["
                    << s << "][" << m << "]";
          }
          evalg << ";" << endl;
        }
        evalg << endl;
      }
      evalg << endl;
    }
    evalg << endl;

    // generating dYTTomega
    evalg << endl << "   // Generate dYTTomega" << endl;
    for (int i = 0; i < nop; ++i) {
      for (int s = 0; s < nop; ++s) {
        evalg << "   dYTTomega[" << i << "][" << s << "] = 0.0";
        for (int r = 0; r < nreac; ++r) {
          if (nu[Iop[i] - 1][r] != 0)
            evalg << " + (" << nu[Iop[i] - 1][r] << ") * dYTTq[" << r << "]["
                  << s << "]";
        }
        evalg << ";" << endl;
      }
      evalg << endl;
    }
    evalg << endl;

    // generating dYYYf
    evalg << endl << "   // Generate dYYYf" << endl;
    for (int i = 0; i < nop; ++i) {
      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          for (int k = 0; k < nop; ++k) {
            evalg << "   dYYYf[" << i << "][" << s << "][" << m << "][" << k
                  << "] = Ms[" << Iop[i] - 1 << "] * ( 1/rho * dYYYomega[" << i
                  << "][" << s << "][" << m << "][" << k << "]";
            evalg << " - 1/(rho*rho) * (dYYrho[" << m << "][" << k
                  << "] * dYomega[" << i << "][" << s << "] + dYYrho[" << s
                  << "][" << k << "] * dYomega[" << i << "][" << m
                  << "] + dYYrho[" << s << "][" << m << "] * dYomega[" << i
                  << "][" << k << "] + dYrho[" << k << "] * dYYomega[" << i
                  << "][" << s << "][" << m << "] + dYrho[" << m
                  << "] * dYYomega[" << i << "][" << s << "][" << k
                  << "] + dYrho[" << s << "] * dYYomega[" << i << "][" << m
                  << "][" << k << "] + omega[" << i << "] * dYYYrho[" << s
                  << "][" << m << "][" << k << "])";
            evalg << " + 2/(rho*rho*rho) * ( omega[" << i << "] * ( dYrho[" << k
                  << "] * dYYrho[" << s << "][" << m << "] + dYrho[" << m
                  << "] * dYYrho[" << s << "][" << k << "] + dYrho[" << s
                  << "] * dYYrho[" << m << "][" << k << "]) + dYrho[" << k
                  << "] * dYrho[" << m << "] * dYomega[" << i << "][" << s
                  << "] + dYrho[" << k << "] * dYrho[" << s << "] * dYomega["
                  << i << "][" << m << "] + dYrho[" << s << "] * dYrho[" << m
                  << "] * dYomega[" << i << "][" << k << "])";
            evalg << " - 6/(rho*rho*rho*rho) * dYrho[" << k << "] * dYrho[" << s
                  << "] * dYrho[" << m << "] * omega[" << i << "]);" << endl;
          }
        }
        evalg << endl;
      }
      evalg << endl;
    }
    evalg << endl;

    // generating dYYTf
    evalg << endl << "   // Generate dYYTf" << endl;
    for (int i = 0; i < nop; ++i) {
      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          evalg << "   dYYTf[" << i << "][" << s << "][" << m << "] = Ms["
                << Iop[i] - 1 << "] * ( 1/rho * (dYYTomega[" << i << "][" << s
                << "][" << m << "] + 1/T * dYYomega[" << i << "][" << s << "]["
                << m << "])";
          evalg << " - 1/(rho*rho) * (dYrho[" << m << "] * dYTomega[" << i
                << "][" << s << "] + dYYrho[" << s << "][" << m
                << "] * dTomega[" << i << "] + dYrho[" << s << "] * dYTomega["
                << i << "][" << m << "] + 1/T * dYrho[" << m << "] * dYomega["
                << i << "][" << s << "] + 1/T * dYYrho[" << s << "][" << m
                << "] * omega[" << i << "] + 1/T * dYrho[" << s
                << "] * dYomega[" << i << "][" << m << "])";
          evalg << " + 2/(rho*rho*rho) *  dYrho[" << s << "] * dYrho[" << m
                << "] * (dTomega[" << i << "] + omega[" << i << "]/T));";
        }
        evalg << endl;
      }
      evalg << endl;
    }
    evalg << endl;

    // generating dYTTf
    evalg << endl << "   // Generate dYTTf" << endl;
    for (int i = 0; i < nop; ++i) {
      for (int s = 0; s < nop; ++s) {
        evalg << "   dYTTf[" << i << "][" << s << "] = Ms[" << Iop[i] - 1
              << "] * ( 1/rho * (dYTTomega[" << i << "][" << s
              << "] + 2/T * dYTomega[" << i << "][" << s << "])";
        evalg << " - 1/(rho*rho) *  dYrho[" << s << "] * (dTTomega[" << i
              << "] + 2*dTomega[" << i << "]/T));";
      }
      evalg << endl;
    }
    evalg << endl;
  }

  // close function
  evalg << endl << "}" << endl << endl;

  evalg.close();
}

void generatePythonTools(vector<string> species, vector<double> Ms,
                         vector<double> Ma, vector<vector<double>> consMatrix,
                         vector<vector<double>> nasa,
                         vector<double> switchingPoints, string path) {

  // get nspec and time for time stamp
  int nspec = species.size();
  int natom = consMatrix.size();
  int nop = NOP;
  int nnop = NNOP;
  int Iop[NOP] = IOP;
  int Inop[NNOP] = INOP;

  time_t t;
  time(&t);

  ofstream out("calculateEnthalpy.py");
  out << "# Autogenerated file on " << ctime(&t);
  out << "# calculateEnthalpy.py" << endl;
  out << "#    Description: Calculates the specific enthalpy of X = (Y,T)"
      << endl;
  out << "#    Input: X = (Y,T) whereas Y are mass fractions of species, T "
         "temperature."
      << endl;
  out << "#    Output: h = caluclated specific enthalpy." << endl;
  out << "import numpy as np" << endl;
  out << "def calculateEnthalpy(X):" << endl << endl;
  out << "\t#set variables" << endl;
  out << "\tY = X[0:-1]" << endl;
  out << "\tHlow = np.zeros(" << nspec << ")" << endl;
  out << "\tHhigh = np.zeros(" << nspec << ")" << endl;
  out << "\tH = np.zeros(" << nspec << ")" << endl;
  out << "\tT = X[-1]" << endl;
  out << "\tTvec = np.array([T, T**2/2.0, T**3/3.0, T**4/4.0, T**5/5.0, 1 ,0 ])"
      << endl;
  out << "\tR = 8.3144598" << endl;
  out << "\tgamma  = 20 # transition parameter" << endl;
  out << endl;

  out << "\tMs = np.array([";
  for (int i = 0; i < Ms.size(); ++i) {
    out << std::setprecision(15) << 1e-3 * Ms[i] << ",";
  }
  out << "]) # molar weights in kg/mol" << endl;

  // generating nasa
  out << "\tnasa = np.array([";
  for (int i = 0; i < nspec; ++i) {
    if (i == 0) {
      out << "[";
    } else {
      out << "\t[";
    }
    for (int k = 0; k < 14; ++k) {
      out << nasa[i][k] << ",";
    }
    out << "]," << endl;
  }
  out << "\t]) # coefficients for nasa polynomials - each line: "
         "[a1_low,...,a7_low,a1_high,..,a7_high]"
      << endl;

  // generating switching points
  out << "\tT_sw = np.array([";
  for (int k = 0; k < nspec; ++k) {
    out << switchingPoints[k] << ",";
  }
  out << "])" << endl;

  out << endl;

  // calculate Hlow, Hhigh
  out << "\tfor s in range(0," << nspec << "):" << endl;
  out << "\t   Hlow[s] = R*np.sum(nasa[s,0:7] * Tvec)" << endl;
  out << "\t   Hhigh[s] = R*sum(nasa[s,7::] * Tvec)" << endl;
  out << "\t   sigma = 1/2*np.tanh(gamma*(T-T_sw[s])) + 1/2" << endl;
  out << "\t   H[s] = (1-sigma)*Hlow[s] + sigma*Hhigh[s]" << endl;
  out << endl;
  // set enthalpy
  out << "\th = np.dot(H,Y/Ms)" << endl;
  out << "\treturn h" << endl;

  // close file
  out.close();

  out.open("getResolution.py");
  out << "# Autogenerated file on " << ctime(&t);
  out << "# getResolution.py" << endl;
  out << "#    Description: Resolve the mass constraints and returns function "
         "handles"
      << endl;
  out << "#                 to represent Inop species." << endl;
  out << "#    Input: ammsock object." << endl;
  out << "#    Output: list including resolutions of Inop species." << endl;
  out << "import numpy as np" << endl;
  out << "import sys" << endl;
  out << "import sympy" << endl;
  out << "import copy" << endl;
  out << "def getResolution(ammsock):" << endl << endl;
  out << "\t# get data" << endl;
  out << "\tInop = ammsock.Inop" << endl;
  out << "\tIop = ammsock.Iop" << endl;
  out << "\tatomFixed = ammsock.atomCons" << endl << endl;
  out << "\t# check if there should be a resolution" << endl;
  out << "\tif not list(Inop):" << endl;
  out << "\t  func_string = np.array([])" << endl;
  out << "\telse:" << endl;
  out << "\t# define conservation matrix" << endl;
  out << "\t   consMatrix = np.array([";
  for (int a = 0; a < natom; ++a) {
    if (a == 0) {
      out << "[";
    } else {
      out << "\t[";
    }
    for (int s = 0; s < nspec; ++s) {
      out << setprecision(20) << consMatrix[a][s] << ",";
    }
    out << "]," << endl;
  }
  out << "\t])" << endl << endl;

  out << "\t   # check if resolution is posssible by checking rank" << endl;
  out << "\t   if np.linalg.matrix_rank(consMatrix[:,Inop-1]) != "
         "consMatrix.shape[0]:"
      << endl;
  out << "\t      sys.exit('Resolution is not possible. Please choose other "
         "species.')"
      << endl;
  out << endl;

  out << "\t   # define symbolic variables" << endl;
  /*out << "syms ";
  for (int s = 0; s < nspec; ++s) {
          out << "Y" << s+1 << " ";
  }
  for (int a = 0; a < natom; ++a) {
          out << "consAtom" << a+1 << " ";
  }
  out << ";" << endl;*/
  out << "\t   Y = np.array([";
  for (int s = 0; s < nspec; ++s) {
    out << "sympy.Symbol('Y" << s + 1 << "'),";
  }
  out << "])" << endl << endl;
  out << "\t   rhs = np.array([";
  for (int a = 0; a < natom; ++a) {
    out << "sympy.Symbol('consAtom" << a + 1 << "'),";
  }
  out << "])" << endl << endl;

  out << "\t   # solve linear equation system" << endl;
  out << "\t   sol = sympy.solve(np.dot(consMatrix,Y)-rhs,list(Y[Inop-1]))"
      << endl;
  out << endl;

  out << "\t   # differentiate each solution" << endl;
  out << "\t   diffstring = [0]*Inop.size" << endl;
  out << "\t   for i in range(0,Inop.size):" << endl;
  out << "\t      diffstring[i] = ''" << endl;
  out << "\t      for j in range(0,Iop.size):" << endl;
  out << "\t          diffstring[i] = diffstring[i] + ', (double)' + "
         "str(sympy.diff(sol[Y[Inop-1][i]],Y[Iop-1][j]))"
      << endl;
  out << "\t      diffstring[i] = diffstring[i][1:len(diffstring[i])+1]"
      << endl;
  out << endl;

  out << "\t   # get string of solutions" << endl;
  out << "\t   sol_string = [0]*Inop.size" << endl;
  out << "\t   for i in range(0,Inop.size):" << endl;
  out << "\t      sol_string[i] = str(sol[Y[Inop-1][i]])" << endl;
  out << endl;

  out << "\t   # replace substrings to parse either to python functions or c++"
      << endl;
  out << "\t   Yres_func = [0]*Inop.size" << endl;
  out << "\t   func_string = copy.deepcopy(sol_string)" << endl;
  out << "\t   for j in range(0,Inop.size):" << endl;
  out << "\t       for i in range(Iop.size-1,-1,-1):	" << endl;
  out << "\t           "
         "func_string[j]=func_string[j].replace('Y'+str(Iop[i]),'Y_'+str(i+1))"
      << endl;
  out << "\t           "
         "sol_string[j]=sol_string[j].replace('Y'+str(Iop[i]),'_Y['+str(i)+']')"
      << endl;
  out << "\t       for k in range(0,Inop.size):" << endl;
  out << "\t          func_string[j]=func_string[j].replace('consAtom'+ "
         "str(k+1),'%1.25f'% atomFixed[k])"
      << endl;
  out << "\t          sol_string[j]=sol_string[j].replace('consAtom' + "
         "str(k+1),'consAtom['+str(k)+ ']')"
      << endl;
  out << "\t       func_string[j]=func_string[j].replace('Y_','Y')" << endl;
  out << endl << endl;

  out << "\t# write resolution to *.hpp file" << endl;
  out << "\tfid = open(ammsock.workingDir + '/cpp/resolution.hpp', 'w')"
      << endl;
  out << "\tfor i in range(0,Inop.size):" << endl;
  out << "\t    fid.write('#define Y' + str(Inop[i]-1) + 'RES ' "
         "+str(sol_string[i]) + '\\n');"
      << endl;
  out << "\tfor i in range(0,Inop.size):" << endl;
  out << "\t    fid.write('#define DIFFY' + str(Inop[i]-1) + 'RES {' + "
         "str(diffstring[i]) + '}' + '\\n');"
      << endl;
  out << "\tfid.close();" << endl;
  out << endl;
  out << "\treturn func_string" << endl;
  // close file
  out.close();

  out.open("getFullState.py");
  out << "# Autogenerated file on " << ctime(&t);
  out << "# getFullState.py" << endl;
  out << "#    Description: Reconstruct the full state vector according"
      << endl;
  out << "#                 to the resolutions of mass constraints." << endl;
  out << "#    Input: reduced state vectors V in IR^(nx times nspec+1)" << endl;
  out << "#           ammsock object" << endl;
  out << "#    Output: Full state vectors F." << endl;
  out << "import numpy as np" << endl;
  out << "def getFullState(V,ammsock):" << endl << endl;
  out << "\t# get data" << endl;
  out << "\tYres = ammsock.Yres" << endl;
  out << "\tnspec = ammsock.nspec" << endl << endl;
  out << "\t#allocate memory" << endl;
  out << "\tV = np.asmatrix(V)" << endl;
  out << "\tnx = V.shape[0]" << endl;
  out << "\tF = np.zeros(shape=(nx,nspec+1))" << endl << endl;

  out << "\tfor i in range(0,nx):" << endl;
  out << "\t   #set Iop states" << endl;
  for (int i = 0; i < nop; ++i) {
    out << "\t   F[i," << Iop[i] - 1 << "] = V[i," << i << "];" << endl;
  }
  out << "\t   #set Inop states" << endl;
  for (int i = 0; i < nop; ++i) {
    out << "\t   Y" << i + 1 << " = V[i," << i << "]" << endl;
  }
  for (int i = 0; i < nnop; ++i) {
    out << "\t   F[i," << Inop[i] - 1 << "] = eval(Yres[" << i << "])" << endl;
  }
  out << "\t   #set temperature" << endl;
  out << "\t   F[i," << nspec << "] = V[i,-1]" << endl;
  out << "\treturn F" << endl;
  out.close();

  out.open("getFixedAtomValues.py");
  out << "# Autogenerated file on " << ctime(&t);
  out << "# getFixedAtomValues.py" << endl;
  out << "#    Description: Calculate the conservation constants of each atom"
      << endl;
  out << "#    Input: mixture fraction Z in [0,1]" << endl;
  out << "#    Output: vector containing conservation constants according"
      << endl;
  out << "#            to order in ammsock.atoms." << endl;
  out << "import numpy as np" << endl;
  out << "import os" << endl;
  out << "import sys" << endl;
  out << endl;
  out << "#add workingDir/python to search path to import getInitialValue.py"
      << endl;
  out << "path = '" << path << "'" << endl;
  out << "new_path = path.replace('\mech','\python')" << endl;
  out << "sys.path.append(os.path.abspath(new_path))" << endl;
  out << "from getInitialValue import *" << endl;
  out << endl;
  out << "def getFixedAtomValues(Z):" << endl << endl;
  out << "\t# define conservation matrix" << endl;
  out << "\tconsMatrix = np.array([";
  for (int a = 0; a < natom; ++a) {
    if (a == 0) {
      out << "[";
    } else {
      out << "\t[";
    }
    for (int s = 0; s < nspec; ++s) {
      out << setprecision(20) << consMatrix[a][s] << ",";
    }
    out << "]," << endl;
  }
  out << "\t])" << endl << endl;

  out << "\t# use getInitialValue and consMatrix to calculate cA" << endl;
  out << "\tYinit = getInitialValue(Z,-42)" << endl;
  out << "\tYinit = np.delete(Yinit,len(Yinit)-1)" << endl;
  out << "\tcA = np.dot(consMatrix,Yinit)" << endl;
  out << "\treturn cA" << endl;

  out.close();

  out.open("getInitialValue.py");
  out << "# Autogenerated file on " << ctime(&t);
  out << "# getInitialValue.py" << endl;
  out << "#    Description: Calculate an initial value according to mixture "
         "fraction"
      << endl;
  out << "#    Input: mixture fraction Z in [0,1]" << endl;
  out << "#    Output: initial value" << endl;
  out << "import numpy as np" << endl;
  out << "def getInitialValue(Z,T):" << endl << endl;

  string fuel = FUEL;
  string oxidizer = OXIDIZER;
  int index, index2, index3;
  index = getIndexOfToken(fuel, species);
  out << "\t# set indicies for fuel and oxidizer" << endl;
  out << "\tindex_fuel = " << index << endl << endl;
  out << "\tm_fuel = " << setprecision(15) << 1e-3 * Ms[index] << endl
      << endl; // convert to kg

  if (oxidizer.compare("O2") == 0) {
    index = getIndexOfToken("O2", species);
    out << "\tindex_oxidizer = np.array([" << index << "])" << endl << endl;
    out << "\tratio_oxidizer = np.array([1])" << endl;
    out << "\tm_oxidizer = np.array([" << 1e-3 * Ms[index] << "])" << endl
        << endl; // convert to kg
  } else if (oxidizer.compare("Air(N2,O2)") == 0) {
    index = getIndexOfToken("O2", species);
    index2 = getIndexOfToken("N2", species);
    out << "\tindex_oxidizer = np.array([" << index << ", " << index2 << "])"
        << endl;
    out << "\tratio_oxidizer = np.array([0.21 ,0.79])" << endl;
    out << "\tm_oxidizer = np.array([" << 1e-3 * Ms[index] << ", "
        << 1e-3 * Ms[index2] << "])" << endl; // convert to kg
  } else if (oxidizer.compare("Air(N2,O2,Ar)") == 0) {
    index = getIndexOfToken("O2", species);
    index2 = getIndexOfToken("N2", species);
    index3 = getIndexOfToken("Ar", species);
    out << "\tindex_oxidizer = np.array([" << index << ", " << index2 << ", "
        << index3 << "])" << endl;
    out << "\tratio_oxidizer = np.array([0.21 ,0.781 ,0.009])" << endl;
    out << "\tm_oxidizer = np.array([" << 1e-3 * Ms[index] << ", "
        << 1e-3 * Ms[index2] << ", " << 1e-3 * Ms[index3] << "])"
        << endl; // convert to kg
  }
  out << endl;

  out << "\t# caluclate total mass fraction" << endl;
  out << "\tm_all = Z*m_fuel + (1-Z)*np.sum(m_oxidizer*ratio_oxidizer)" << endl
      << endl;

  out << "\t# set initial value" << endl;
  out << "\tYinit = np.zeros(" << nspec + 1 << ")" << endl;
  out << "\tYinit[index_fuel] = Z*m_fuel/m_all" << endl;
  out << "\tfor i in range(0,len(index_oxidizer)):" << endl;
  out << "\t   Yinit[index_oxidizer[i]] = "
         "(1-Z)*ratio_oxidizer[i]*m_oxidizer[i]/m_all"
      << endl;
  out << "\tYinit[-1] = T" << endl << endl;
  out << "\treturn Yinit" << endl;

  out.close();

  out.open("computeManifold.py");
  out << "# Autogenerated file on " << ctime(&t);
  out << "# computeManifold.py" << endl;
  out << "#    Description: Calculate the slow invariant manifold points."
      << endl;
  out << "#    Input: grid_rpv - list with discretizations of each reaction"
      << endl;
  out << "#                      progress variable." << endl;
  out << "#           init - inital guess." << endl;
  out << "#           ammsock - ammsock object." << endl;
  out << "#    Output: SIM - a min(nSim, successfulReduction) times nspec+1 "
         "matrix"
      << endl;
  out << "#                  containing the successfully computed SIM points."
      << endl;
  out << "#            it - required iterations for each SIM point." << endl;
  out << "from performReduction import *" << endl;
  out << "import numpy as np" << endl;
  out << "import sys" << endl;
  out << "def computeManifold(grid_rpv,initalvalue,ammsock):" << endl << endl;

  out << "\t# check if grid_rpv has valid dimension" << endl;
  out << "\tif len(grid_rpv) != ammsock.nrpv:" << endl;
  out << "\t  sys.exit('computeManifold: grid_rpv must be a cell array with "
         "dimension (1 x nrpv).')"
      << endl;
  out << endl;
  out << "\t# check if elements of grid_rpv are arrays or lists" << endl;
  out << "\tfor i in range(0,len(grid_rpv)):" << endl;
  out << "\t   if not isinstance(grid_rpv[i],(list,np.ndarray)):" << endl;
  out << "\t      sys.exit('computeManifold: elements in grid_rpv have to be "
         "lists or arrays')"
      << endl;
  out << endl;

  out << "\t# setting parameters" << endl;
  out << "\tparam={'hfixed':ammsock.hfixed}" << endl;
  out << "\tparam['atomCons'] = list(ammsock.atomCons)" << endl;
  out << "\tparam['maxit'] = ammsock.maxit" << endl;
  out << "\tparam['hcoll'] = ammsock.hcoll" << endl;
  out << "\tparam['scale'] = ammsock.scale" << endl;
  out << "\tnrpv = ammsock.nrpv" << endl << endl;
  out << "\tindexRpv = []" << endl;
  out << "\tfor i in range(0,nrpv):" << endl;
  out << "\t   "
         "indexRpv.append(int(np.where(ammsock.Iop==ammsock.indexRpv[i])[0][0])"
         ")"
      << endl;

  out << "\tif ammsock.exactHessian=='true':" << endl;
  out << "\t   param['exactHessian'] = 1" << endl;
  out << "\telif ammsock.exactHessian=='false':" << endl;
  out << "\t   param['exactHessian'] = 0" << endl;
  out << "\telse:" << endl;
  out << "\t   sys.exit('computeManifold: exactHessian must be true or false.')"
      << endl;
  out << endl;

  out << "\t# initialize output parameters" << endl;
  out << "\tSIM_tmp = []" << endl;
  out << "\tit = []" << endl;
  out << "\tinit = initalvalue" << endl << endl;

  out << "\t# loop over grid" << endl;
  for (int i = 0; i < NRPV; ++i) {
    out << "\t" << std::string(i * 3, ' ') << "for k" << i
        << " in range(0,len(grid_rpv[" << i << "])):" << endl;
  }
  out << "\t" << std::string(NRPV * 3, ' ') << "p = [";
  for (int i = 0; i < NRPV; ++i) {
    out << "grid_rpv[" << i << "][k" << i << "], ";
  }
  out << "]" << endl;
  out << "\t" << std::string(NRPV * 3, ' ') << "print(p)" << endl;
  out << "\t" << std::string(NRPV * 3, ' ')
      << "[exit,nit,yfull] = Reduction(p,init,param)" << endl;
  out << "\t" << std::string(NRPV * 3, ' ')
      << "#check if reduction was successful" << endl;
  out << "\t" << std::string(NRPV * 3, ' ')
      << "if (exit == 0) or (exit == 1):" << endl;
  out << "\t" << std::string(NRPV * 3 + 3, ' ') << "\tSIM_tmp.append(yfull)"
      << endl;
  out << "\t" << std::string(NRPV * 3 + 3, ' ') << "\tinit = yfull" << endl;
  out << "\t" << std::string(NRPV * 3, ' ') << "it.append(nit)" << endl;
  out << "\t" << std::string(NRPV * 3, ' ') << "print(it)" << endl;
  out << "\t" << std::string(NRPV * 3, ' ') << "print(exit)" << endl;
  out << endl;
  for (int i = 0; i < NRPV; ++i) {
    out << endl;
    if (i < NRPV - 1) {
      out << "\t" << std::string((NRPV - 1 - i) * 3, ' ')
          << "# create SIM matrix" << endl;
      out << "\t" << std::string((NRPV - 1 - i) * 3, ' ')
          << "SIM = np.asarray(SIM_tmp)" << endl;
      out << endl;
      out << "\t" << std::string((NRPV - 1 - i) * 3, ' ')
          << "# get closest previously calculated SIM point" << endl;
      out << "\t" << std::string((NRPV - 1 - i) * 3, ' ')
          << "nSim = SIM.shape[0]" << endl;
      out << "\t" << std::string((NRPV - 1 - i) * 3, ' ')
          << "if nSim > 0:" << endl;
      out << "\t" << std::string((NRPV - 1 - i) * 3 + 3, ' ')
          << "ind =  "
             "np.argmin(np.sum((SIM[:,indexRpv]-np.dot(np.ones(shape=(nSim,"
             "nrpv)),np.diag([";
      for (int k = 0; k < NRPV - i - 1; ++k) {
        out << "grid_rpv[" << k << "][k" << k << "], ";
      }
      for (int k = NRPV - i - 1; k < NRPV; ++k) {
        out << "grid_rpv[" << k << "][0], ";
      }
      out << "])))**2,1))" << endl;
      out << "\t" << std::string((NRPV - 1 - i) * 3 + 3, ' ')
          << "init = list(SIM[ind,:])" << endl;
    }
    if (NRPV == 1) {
      out << "\t" << std::string((NRPV - 1) * 3, ' ') << "# create SIM matrix"
          << endl;
      out << "\t" << std::string((NRPV - 1) * 3, ' ')
          << "SIM = np.asarray(SIM_tmp)" << endl;
      out << endl;
    }
  }
  out << endl;

  out << "\treturn [SIM,it]" << endl;
  out.close();
}

int main(int argc, char *argv[]) {

  // check arguments
  assert(argc == 4);

  // perliminaries
  int nreac = 0, nspec = 0, natom = 0, ntb = 0, nrtb = 0, nfr = 0;

  string line;

  // create streams
  string path = argv[1];
  string filename = argv[2];
  string convertTo = argv[3];

  // read mech data
  ifstream mechdata((path + "/data/mechdata.dat").c_str(), ios_base::in);

  // read species and their molar weights
  getline(mechdata, line);
  istringstream iss(line);
  iss >> nspec;
  vector<string> species(nspec);
  vector<double> Ms(nspec, 0.0);
  for (int s = 0; s < nspec; ++s) {
    getline(mechdata, line);
    istringstream iss(line);
    iss >> species[s];
    iss >> Ms[s];
  }

  // read atoms and their molar weights
  getline(mechdata, line);
  istringstream iss_natom(line);
  iss_natom >> natom;
  vector<string> atoms(natom);
  vector<double> Ma(natom, 0.0);
  for (int a = 0; a < natom; ++a) {
    getline(mechdata, line);
    istringstream iss(line);
    iss >> atoms[a];
    iss >> Ma[a];
  }

  // read nreac, nuprime, nu2prime
  getline(mechdata, line);
  istringstream iss_nreac(line);
  iss_nreac >> nreac;
  vector<vector<int>> nuprime;
  vector<vector<int>> nu2prime;
  for (int s = 0; s < nspec; ++s) {
    nuprime.push_back(vector<int>(nreac, 0));
    getline(mechdata, line);
    istringstream iss(line);
    for (int r = 0; r < nreac; ++r) {
      iss >> nuprime[s][r];
    }
  }
  for (int s = 0; s < nspec; ++s) {
    nu2prime.push_back(vector<int>(nreac, 0));
    getline(mechdata, line);
    istringstream iss(line);
    for (int r = 0; r < nreac; ++r) {
      iss >> nu2prime[s][r];
    }
  }

  // read third body collision efficiencies
  getline(mechdata, line);
  istringstream iss_ntb(line);
  iss_ntb >> ntb;
  vector<vector<double>> bodyCoeff;
  for (int i = 0; i < ntb; ++i) {
    bodyCoeff.push_back(vector<double>(nspec, 0));
    getline(mechdata, line);
    istringstream iss(line);
    for (int s = 0; s < nspec; ++s) {
      iss >> bodyCoeff[i][s];
    }
  }

  // read third body position and number
  getline(mechdata, line);
  istringstream iss_nrtb(line);
  iss_nrtb >> nrtb;
  vector<int> bodyPos(nrtb, 0);
  vector<int> bodyNumber(nrtb, 0);
  for (int i = 0; i < nrtb; ++i) {
    getline(mechdata, line);
    istringstream iss(line);
    iss >> bodyPos[i];
    iss >> bodyNumber[i];
  }

  // read third body info
  getline(mechdata, line);
  istringstream iss_nfr(line);
  iss_nfr >> nfr;
  vector<int> forwardReactions(nfr, 0);
  for (int i = 0; i < nfr; ++i) {
    getline(mechdata, line);
    istringstream iss(line);
    iss >> forwardReactions[i];
  }

  // read conservation matrix
  vector<vector<double>> consMatrix(natom, vector<double>(nspec, 0.0));
  for (int a = 0; a < natom; ++a) {
    getline(mechdata, line);
    istringstream iss(line);
    for (int s = 0; s < nspec; ++s) {
      iss >> consMatrix[a][s];
    }
  }

  // open thermodata
  ifstream thermodata((path + "/data/thermodata.dat").c_str(), ios_base::in);
  vector<double> A(nreac, 0.0), b(nreac, 0.0), Ea(nreac, 0.0);
  vector<vector<double>> nasa(nspec, vector<double>(14, 0.0));
  vector<double> switchingPoints(nspec, 0.0);

  // read A, b and Ea for each reaction
  for (int r = 0; r < nreac; ++r) {
    getline(thermodata, line);
    istringstream iss(line);
    iss >> A[r];  // A
    iss >> b[r];  // b
    iss >> Ea[r]; // Ea
  }

  // read nasa polynomials coefficients and switching points
  for (int s = 0; s < nspec; ++s) {
    getline(thermodata, line);
    istringstream iss(line);
    for (int k = 0; k < 14; ++k) {
      iss >> nasa[s][k];
    }
    iss >> switchingPoints[s];
  }

  // generating code

  generateRates(A, b, Ea, species, nuprime, nu2prime, Ms, forwardReactions,
                nasa, switchingPoints, convertTo, filename);

  if (convertTo.compare("c++") == 0) {
    generateEvalF(nspec, nreac, species, nuprime, nu2prime, bodyPos, bodyNumber,
                  bodyCoeff, Ms, filename);
    generateEvalGradF(nspec, nreac, species, nuprime, nu2prime, bodyPos,
                      bodyNumber, bodyCoeff, Ms, filename);
    generateEvalG(species, nuprime, nu2prime, consMatrix, Ms, bodyPos,
                  bodyNumber, bodyCoeff, filename);
    generateEvalJacG(species, nuprime, nu2prime, consMatrix, Ms, bodyPos,
                     bodyNumber, bodyCoeff, filename);
    generateEvalH(nspec, nreac, species, nuprime, nu2prime, bodyPos, bodyNumber,
                  bodyCoeff, Ms, filename);
    generateAuxiliary(species, nuprime, nu2prime, consMatrix, Ms, bodyPos,
                      bodyNumber, bodyCoeff, filename);
    generateBoundsInfo(nspec, species, natom, filename);
    generateNLPInfo(nspec, species, natom, filename);
  }

  if (convertTo.compare("python") == 0) {
    generateRHS(nspec, nreac, natom, species, nuprime, nu2prime, bodyPos,
                bodyNumber, bodyCoeff, Ms, nasa, switchingPoints, filename,
                path);
    generatePythonTools(species, Ms, Ma, consMatrix, nasa, switchingPoints,
                        path);
  }

  cout << "\n*** Generator: Work done. " << convertTo << "-Code generated. ***"
       << endl
       << endl;

  return 0;
}
